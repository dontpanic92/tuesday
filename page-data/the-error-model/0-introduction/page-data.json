{"componentChunkName":"component---gatsby-theme-apollo-docs-src-components-template-js","path":"/the-error-model/0-introduction/","result":{"data":{"site":{"pathPrefix":"","siteMetadata":{"title":"Tuesday.","description":"dontpanic 的技术专栏"}},"file":{"sourceInstanceName":"content","childMarkdownRemark":{"frontmatter":{"title":"〇、错误模型简介","description":"Introduction","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/ac982c968177cf6bf72d4c6b4fa920b6/6a249/cover.jpg","srcSet":"/static/ac982c968177cf6bf72d4c6b4fa920b6/11ab8/cover.jpg 360w,\n/static/ac982c968177cf6bf72d4c6b4fa920b6/c9a94/cover.jpg 720w,\n/static/ac982c968177cf6bf72d4c6b4fa920b6/6a249/cover.jpg 1440w","sizes":"(min-width: 1440px) 1440px, 100vw"},"sources":[{"srcSet":"/static/ac982c968177cf6bf72d4c6b4fa920b6/e02de/cover.webp 360w,\n/static/ac982c968177cf6bf72d4c6b4fa920b6/4c661/cover.webp 720w,\n/static/ac982c968177cf6bf72d4c6b4fa920b6/0a83a/cover.webp 1440w","type":"image/webp","sizes":"(min-width: 1440px) 1440px, 100vw"}]},"width":1440,"height":720}}}},"headings":[{"value":"错误模型简介","depth":2}],"fields":{"image":"","apiReference":false},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"译注："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"原作者 Joe Duffy 曾在微软参与开发一款操作系统 Midori，这是一款研究型/孵化型项目。这款操作系统主要由一种 C# 的变种语言（有人称作 M# 语言）编写。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下文中所有的“我”、“我们”均指代原作者 Joe Duffy 或其所在团队。作者总结了目前主流编程语言中常见的错误模型的优缺点，同时分别给出了自己的针对不可恢复错误（Unrecoverable Error）和可恢复错误（Recoverable Error）的处理方案。由于本文有一些惯用语和专业词语，受限于我的水平，可能出现翻译错误、或措辞与主流方案不同等问题，欢迎指出以便修正。本文较长，请做好长时间阅读的准备。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"原文链接："},{"type":"element","tagName":"a","properties":{"href":"http://joeduffyblog.com/2016/02/07/the-error-model/"},"children":[{"type":"text","value":"http://joeduffyblog.com/2016/02/07/the-error-model/"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Midori 使用了一种基于 C# 的、支持 AOT 编译、类型安全的语言。除了我们的微内核，整个系统都是使用这种语言编写的，包括驱动程序、域内核（Domain Kernel），以及全部的用户代码。我在这段时间里收获了很多，现在是时候总结一下了。整个语言涵盖的东西太多了，我会分成几篇文章来阐述，就先从错误模型开始。错误（Errors）的传递与处理在任何编程语言中都是非常基础的部分，而对于用来编写高可靠操作系统的语言来说更是如此。就像 Midori 项目的其他部分一样，任何修改一部分都应该从全局的角度来考量，并进行不断地迭代。我经常从原来的同事那里听到说，错误模型是他们在 Midori 上开发程序时最怀念的部分。我也很怀念这部分。那么废话少说，我们这就开始。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{"id":"错误模型简介","style":"position:relative;"},"children":[{"type":"element","tagName":"a","properties":{"href":"#%E9%94%99%E8%AF%AF%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B","ariaLabel":"错误模型简介 permalink","className":["anchor","before"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]},{"type":"text","value":"错误模型简介"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"错误模型需要回答的最基本的问题是：“错误”应该如何传达给程序员和用户？这问题似乎很简单。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要回答这个问题，最大的阻碍之一是：如何定义什么是“错误”。很多语言把 Bug 和可恢复错误归为一类，用同样的机制来处理，比如把空指针引用错误、数组访问越界错误与网络连接错误、语法分析错误混为一谈。这种一致性初看起来很美好，但它有着深层次的问题——这种一致性会造成很大误解，并且通常会导致程序员写出不可靠的代码。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"总的来说，我们的解决方法是同时提供两套错误模型。一方面，对于程序的 Bug，我们提供了快速失败（Fail-Fast）模型，在 Midori 中我们称其为放弃（Abandonment）；另一方面，对于可恢复的错误，我们也提供了静态受检查异常（Statically Checked Exception）。这两种错误模型从编程模式到背后的机制都截然不同。放弃会无条件地立即终止整个进程，不会再运行任何用户代码（需要说明的是：一个典型的 Midori 程序会由很多个小的、轻量级的进程组成）；异常则允许恢复用户代码的执行，在这个过程中类型系统会起到重要的检查和验证的作用。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们的旅程漫长而曲折。为了讲好这段故事，这篇文章分为以下6个主要部分："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"野心和经验"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Bugs 不是可恢复错误！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"可靠性、容错性和隔离性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Bugs：放弃（Abandonment）、断言（Assertions）和合约（Contracts）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"可恢复错误：类型导向的异常回顾与总结"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"现在看来，有些结论似乎很明显，尤其是在更现代的系统语言（比如 Go 和 Rust）出现之后。但是一些结论还是让我们很惊讶。我会尽量省略废话，但也会提供足够的背景故事。我们走过很多弯路，但我觉得这些弯路甚至要比最终的结论更有趣。"}]}],"data":{"quirksMode":false}}},"childMdx":null}},"pageContext":{"id":"f58817c2-798e-51e1-95f9-5743d8e5b436","versionDifference":0,"versionBasePath":"/v2","sidebarContents":[{"title":null,"pages":[]},{"title":"公共语言运行时","pages":[{"title":"一、CLR 简介","sidebarTitle":"","description":null,"path":"/botr/1-introduction/"},{"title":"二、CLR 垃圾回收器的设计","sidebarTitle":"","description":null,"path":"/botr/2-garbage-collection/"},{"title":"六、CLR 类型加载器的设计","sidebarTitle":"","description":null,"path":"/botr/6-type-loader/"}]},{"title":"错误模型","pages":[{"title":"〇、错误模型简介","sidebarTitle":"","description":"Introduction","path":"/the-error-model/0-introduction/"},{"title":"一、野心和经验","sidebarTitle":"","description":"Ambitions and Learnings","path":"/the-error-model/1-ambitions-and-learnings/"},{"title":"二、Bug 不是可恢复错误！","sidebarTitle":"","description":"Bugs Aren’t Recoverable Errors!","path":"/the-error-model/2-bugs-arent-recoverable-errors/"},{"title":"三、可靠性、容错性和隔离性","sidebarTitle":"","description":"Reliability, Fault-Tolerance, and Isolation","path":"/the-error-model/3-reliability-fault-tolerance-and-isolation/"},{"title":"四、Bugs：放弃、断言和合约","sidebarTitle":"","description":"Bugs: Abandonment, Assertions, and Contracts","path":"/the-error-model/4-bugs-abandonment-assertions-and-contracts/"},{"title":"五、可恢复错误：类型导向的异常","sidebarTitle":"","description":"Recoverable Errors: Type-Directed Exceptions","path":"/the-error-model/5-ecoverable-errors-type-directed-exceptions/"},{"title":"六、回顾和总结","sidebarTitle":"","description":"Retrospective and Conclusions","path":"/the-error-model/6-retrospective-and-conclusions/"}]},{"title":"栈缓冲区溢出 101","pages":[{"anchor":true,"title":"一、栈缓冲区溢出 101","path":"https://ctf.dontpanic.blog/notes/stack-buffer-overflow-101.html"},{"anchor":true,"title":"二、ASLR","path":"https://ctf.dontpanic.blog/notes/stack-buffer-overflow-aslr.html"},{"anchor":true,"title":"三、Security Cookie / Canary","path":"https://ctf.dontpanic.blog/notes/stack-buffer-overflow-canary.html"}]}],"versions":[],"defaultVersion":"2"}},"staticQueryHashes":["1511030359","2468095761","2645605535"]}