{"data":{"allFile":{"edges":[{"node":{"id":"9d5ca77f-c4ec-5f12-9ba4-a5452f5cb356","relativePath":"md-placeholder.md","childMarkdownRemark":{"fields":{"slug":"/md-placeholder/"},"frontmatter":{"title":"placeholder"},"html":""},"childMdx":null}},{"node":{"id":"797b7e45-09d8-525c-a1d0-77127773d99f","relativePath":"mdx-placeholder.mdx","childMarkdownRemark":null,"childMdx":{"fields":{"slug":"/mdx-placeholder/"},"frontmatter":{"title":"placeholder"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"placeholder\",\n  \"description\": \"placeholder\",\n  \"featuredImage\": \"placeholder.png\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;"}}},{"node":{"id":"ec01e5d9-ca51-52b4-8baa-975e0b73597d","relativePath":"botr/1-introduction.md","childMarkdownRemark":{"fields":{"slug":"/botr/1-introduction/"},"frontmatter":{"title":"一、CLR 简介"},"html":"<blockquote>\n<p>这是一篇译文。作者：Vance Morrison - 2007<br>\n原文链接：<a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/intro-to-clr.md\">https://github.com/dotnet/coreclr/blob/master/Documentation/botr/intro-to-clr.md</a></p>\n</blockquote>\n<h2 id=\"什么是-clr-\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-clr-\" aria-label=\"什么是 clr  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是 CLR ？</h2>\n<p>什么是公共语言运行时（Common Language Runtime, CLR）？简单来说就是：</p>\n<blockquote>\n<p>公共语言运行时（CLR）是一套完整的、高级的虚拟机，它被设计为用来支持不同的编程语言，并支持它们之间的互操作。</p>\n</blockquote>\n<p>啊，有点绕口，同时也不太直观。不过这样的表述还是 <em>有用的</em> ，它把 CLR 的特性用一种易于理解的方式分了类。由于 <a href=\"http://msdn.microsoft.com/library/8bs2ecf4.aspx\">CLR</a> 实在太过庞大和复杂，这是我们理解它的第一步——犹如从万米高空俯视它，我们可以了解到 CLR 的整体目标；而在这之后，我们就可以带着这种全局观念，更好地详细了解各个子模块。</p>\n<h2 id=\"clr一个很少见的完备的编程平台\" style=\"position:relative;\"><a href=\"#clr%E4%B8%80%E4%B8%AA%E5%BE%88%E5%B0%91%E8%A7%81%E7%9A%84%E5%AE%8C%E5%A4%87%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B9%B3%E5%8F%B0\" aria-label=\"clr一个很少见的完备的编程平台 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CLR：一个（很少见的）完备的编程平台</h2>\n<p>每一个程序都有大量的运行时依赖。当然，一个程序需要由某种特定的编程语言编写而成，不过这只是程序员把想法变成现实的第一步。所有有意义的程序，都免不了需要与一些 <em>运行时库</em> 打交道，以便能够操作机器的其他资源（比如用户输入、磁盘文件、网络通讯，等等）。程序代码还需要某种变换（翻译或编译）才能够被硬件直接执行。这些依赖实在是太多了，不仅种类繁多还互相纠缠，因此编程语言的实现者通常都把这些问题交由其他标准来指定。例如，C++ 语言并没有制定一种 “C++可执行程序” 格式；相反，每个 C++ 编译器都会与特定的硬件架构（例如 x86）以及特定的操作系统（例如 Windows、Linux 或 macOS）绑定，它们会对可执行文件的格式进行描述，并规定要如何加载这些程序。因此，程序员们并不会搞出一个 “C++可执行文件”，而是 “Windows X86 可执行程序” 或 “Power PC Mac OS 可执行程序”。</p>\n<p>通常来说，直接使用现有的硬件和操作系统标准是件好事，但它同样也会把语言规范与现有标准的抽象层次紧密捆绑起来。例如，常见的操作系统并没有支持垃圾回收的堆内存，因此我们就无法用现有的标准来描述一种能够利用垃圾回收优势的接口（例如，把一堆字符串传来传去而不用担心谁来删除它们）。同样，典型的可执行文件格式只提供了运行一个程序所需要的信息，但并没有提供足够的信息能让编译器把其他的二进制文件与这个可执行文件绑定。举例来说，C++ 程序通常都会使用标准库（在 Windows 上叫做 msvcrt.dll），它包含了大多数常用的功能（例如 <code class=\"language-text\">printf</code>），但只有这一个库文件是不行的。程序员如果想使用这个库，必须还要有与它相匹配的头文件（例如 <code class=\"language-text\">stdio.h</code>）才可以。由此可见，现有的可执行文件格式标准无法同时做到：1、满足运行程序的需求；2、提供使程序完整所必须的其他信息或二进制文件。</p>\n<p>CLR 能够解决这些问题，因为它制定了一套<a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md\">非常完整的规范</a>（已被 ECMA 标准化）。这套规范描述了一个程序的<strong>完整</strong>生命周期中所需要的所有细节，从构建、绑定一直到部署和执行。例如，CLR 制订了：</p>\n<ul>\n<li>一个支持 GC 的虚拟机，它拥有自己的指令集（叫做公共中间语言，Common Intermediate Langauge），用来描述程序所能执行的基本操作。这意味着 CLR 并不依赖于某种特定类型的 CPU。</li>\n<li>一种丰富的元数据表示，用来描述一个程序的声明（例如类型、字段、方法等等）。因此编译器能够利用这些信息来生成其他程序，它们能够从“外面”调用这段程序提供的功能。</li>\n<li>一种文件格式，它指定了文件中各个字节所表达的意含义。因此你可以说，一个 “CLR EXE”并没有与某个特定的操作系统或计算机硬件相捆绑。</li>\n<li>已加载程序的生命周期语义，即一种 “CLR EXE 引用其他 CLR EXE” 的机制。同时还制订了一些规则，指定了运行时要如何在执行阶段查找并引用其他文件。</li>\n<li>一套类库，它们能够利用 CLR 所支持的功能（例如垃圾回收、异常以及泛型）来向程序提供一些基本功能（例如整型、字符串、数组、列表和字典），同时也提供了一些与操作系统有关的功能（例如文件、网络、用户交互）。</li>\n</ul>\n<h3 id=\"多语言支持\" style=\"position:relative;\"><a href=\"#%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81\" aria-label=\"多语言支持 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>多语言支持</h3>\n<p>定义、规范以及实现所有这些细节是一项艰巨的任务，这也是为什么像 CLR 一样完备的抽象非常少见。事实上，大部分这些基本完备的抽象都是为某一个语言而生的。例如，Java 运行时、Perl 翻译器、或是早期的 Visual Basic 运行时，都提供了类似的完整的抽象界限。使得 CLR 在这些工作中脱颖而出的是它的多语言支持特性。很多语言，当单独使用时，体验很好；但当与其他语言交互时却非常麻烦（Visual Basic 大概是个例外，因为它使用了 COM 对象模型）。语言之间的交互难点在于，它们只能使用操作系统所提供的基本功能与其他语言进行交互。由于操作系统的抽象层次太低（例如操作系统并不知道支持垃圾回收的堆内存是什么），因此跨语言交互通常都很复杂。通过提供<strong>公共语言运行时</strong>，CLR 允许语言之间使用更高层次的结构进行交互（例如支持 GC 的结构），极大简化了交互的复杂性。</p>\n<p>由于运行时在 <em>很多</em> 语言之间共享，它意味着我们我们可以投入更多的资源在运行时上。为一个语言构建一个优秀的调试器和性能分析器通常需要大量的工作，因此通常来说只有那些最重要的编程语言才拥有完备的调试器和性能分析器。然而，由于在 CLR 上的语言可以复用这些基础设施，为某种语言实现调试器的负担就会减轻很多。更重要的时，任何建立在 CLR 之上的语言，都可以立刻获得访问 <em>所有</em> 类库的能力。这些庞大（并且还在不断完善）的类库是 CLR 成功的另一个重要原因。</p>\n<p>简而言之，运行时就是一套完整的规范，它规定了创建和运行一个程序所需要的方方面面。而负责运行这些程序的虚拟机，非常适合用来实现各种各样的编程语言。这个虚拟机、以及跑在这个虚拟机上的（不断完善的）类库，就是我们所说的公共语言运行时（CLR）。</p>\n<h2 id=\"clr-的主要目标\" style=\"position:relative;\"><a href=\"#clr-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87\" aria-label=\"clr 的主要目标 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CLR 的主要目标</h2>\n<p>现在我们对 CLR 是什么有了一个基本的认识，下面我们就来看看运行时究竟想要解决什么问题。从非常高的角度来说，运行时只有一个目标：</p>\n<blockquote>\n<p>CLR 的目标是让编程变得简单。</p>\n</blockquote>\n<p>这条表述可以从两方面来理解：</p>\n<p>一方面，在运行时不断进化的过程中，这是一条 <em>非常</em> 有用的指导准则。例如，从根本上来说，简洁的东西才会简单。如果某个改动会向运行时中添加<strong>用户可见</strong>的复杂性，我们就需要秉持怀疑的态度来审视。相比于计算某个功能的“成本收益比”，我们更看重“添加的用户可见复杂度“ 与 ”在所有场景上的加权收益” 之比。理想情况下，这个比值应该是负的——即新功能通过减少限制或泛化特例，从而使的复杂性降低。在现实情况下，我们应当尽量最小化暴露给外部的复杂度，并最大化这个功能所适用的场景。</p>\n<p>另一方面，这个目标的重要性在于：<strong>易用性是 CLR 成功的基石</strong>。CLR 并不是因为比原生代码更快更小而成功的（事实上，写的好的原生代码通常在这些方面都会胜出）；CLR 也并不是因为提供了某种特别的功能而成功的（例如垃圾回收、平台无关、面向对象编程或版本管理）。CLR 的成功在于：这些功能、以及其他不计其数的功能加在一起，使得编程变得简单得多。很多很重要但是经常被忽视的易用功能包括：</p>\n<ol>\n<li>简化的语言（例如，C# 和 Virual Basic 要比 C++ 简单太多）</li>\n<li>致力于简化类库（例如，我们只有一种字符串类型，它是不可变的；这极大地简化了适用字符串的 API）</li>\n<li>类库中名称之间很强的一致性（例如，要求 API 使用完整的单词，并使用一致的命名规范）</li>\n<li>对创建一个程序所需要的工具链提供了大力支持（例如，Visual Studio 使得构建 CLR 应用程序非常简单，Intellisense 使得查找正确的类型和方法变得非常容易）</li>\n</ol>\n<p>正是这些在易用性上的努力（它们与用户模型的简单性密切相关），才是 CLR 能够成功的原因。奇怪的是，一些在易用性方面最重要的特性通常都是最“无聊”的。比如，其实任何编程环境都可以提供一致的命名规范，但在如此庞大的类库上保持一致性还是需要很多工作的（译注：黑人问号 PHP）。这样的做法通常会与其他目标冲突（例如与现有接口保持兼容性），或者与做起来比较复杂（例如在一个 <em>非常</em> 大的代码库中重命名一个方法）。正因如此，我们才需要时刻提醒自己，什么才是 CLR 最重要的目标。这样才能够更快地向目标迈进。</p>\n<h2 id=\"clr-的主要功能\" style=\"position:relative;\"><a href=\"#clr-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD\" aria-label=\"clr 的主要功能 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CLR 的主要功能</h2>\n<p>运行时有很多功能，我们可以概括为以下几类：</p>\n<ol>\n<li><strong>基础功能</strong>——那些对其他的特性有广泛影响的功能。包括：\n<ol>\n<li>垃圾回收</li>\n<li>内存安全和类型安全</li>\n<li>对编程语言的高级支持</li>\n</ol>\n</li>\n<li><strong>次要功能</strong>——那些由基础功能发展而来的、但不是必须的功能：\n<ol>\n<li>AppDomains 程序隔离</li>\n<li>程序安全与沙盒</li>\n</ol>\n</li>\n<li><strong>其他功能</strong>——那些运行时环境需要的、但并不依赖基础功能的特性。这些功能帮助我们建立了一个完整的编程环境。比如：\n<ol>\n<li>版本管理</li>\n<li>调试、性能分析</li>\n<li>互操作</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"clr-垃圾回收器\" style=\"position:relative;\"><a href=\"#clr-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8\" aria-label=\"clr 垃圾回收器 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CLR 垃圾回收器</h3>\n<p>在 CLR 所提供的所有功能中，垃圾回收器值得特别关注。垃圾回收（GC）的意思是“内存自动回收”。在一个支持垃圾回收的系统中，用户程序不再需要调用一个特殊的操作符来删除内存。相反，运行时会自动跟踪在 GC 堆内存上的所有内存引用，并且他会不时地遍历这些引用，判断这些内存是不是还会被程序所使用。所有不再被使用的内存就是 <em>垃圾</em>，它们可以被用于新的内存申请。</p>\n<p>垃圾回收是一个非常有用的功能，因为它简化了编程工作。最明显的简化就是，大多数显式的删除操作都可以省略了。当然，省略删除操作这一点很重要，但垃圾回收给程序员带来的真正价值要更微妙一点：</p>\n<ol>\n<li>\n<p>垃圾回收简化了接口设计。没有垃圾回收的话你就需要考虑，究竟接口的哪一侧需要负责删除在接口上传入传出的对象。例如，CLR 的接口就可以很简单地返回一个字符串，我们不需要担心字符串的缓冲区和长度。这也意味着我们也不需要担心“缓冲区是不是足够大”。因此，垃圾允许运行时中所有的接口都要比以前更简洁一些。</p>\n</li>\n<li>\n<p>垃圾回收消除了一些常见的用户错误。对于某一个特定的对象来说，我们非常容易搞错它的生命周期，要么是删除的太早（将会导致内存内容失效），或者删除的太晚（内存泄漏）。一个典型的程序会使用成千上万个对象，出现错误的概率确实很大。更进一步，生命周期这一类的 bug 很难调试，尤其是这个对象被很多其他对象所引用的时候。垃圾回收使得这类错误不会再发生，给我们带来了很大的便利。</p>\n</li>\n</ol>\n<p>垃圾回收非常有用，这一点我们就说到这了。我们还有更重要的事情需要讨论，那就是垃圾回收给运行时带来的这个最直接的需求：</p>\n<blockquote>\n<p>垃圾回收要求运行时跟踪 GC 堆内存上<strong>所有</strong>的引用。</p>\n</blockquote>\n<p>这个要求看起来非常简单，然而事实上它给运行时带来了深远的影响。就像你所想到的那样，在程序运行的每时每刻都要知道每一个指针指向了哪个对象，这太难了。不过，我们可以稍微降低一下需求。从技术上说，只有在真正进行垃圾回收的时候，我们才需要上面这个要求得到满足（因此，理论上说我们并不需要时刻知道所有的 GC 引用，只有在进行 GC 时才需要）。然而在实践中，这个小技巧并不能完全搞定这个问题，因为 CLR 还有另一个特性：</p>\n<blockquote>\n<p>CLR 支持在同一个进程中并发执行多个线程。</p>\n</blockquote>\n<p>在任何时间，某个线程的执行都可能会导致内存的申请，进而可能需要进行一次垃圾回收。并发线程的执行顺序是无法确定的，我们没办法知道当一个线程出发了垃圾回收时另一个线程在干什么。因此，GC 有可能发生在某个线程执行当中的任何时间。CLR 并不需要 <em>立即</em> 响应某个线程的 GC 请求，因此 CLR 确实还是有一定的“回旋余地”的。不过，CLR 还是需要保证它能在一定的时间内对 GC 请求做出响应。</p>\n<p>这说明：CLR 需要 _几乎_随时跟踪 GC 堆上的 <em>所有</em>  引用。GC 引用可能会存放在机器寄存器中、在局部变量中、在静态域或其他域中等等，确实有不少地方需要我们关注。比较难办的是存放在机器寄存器及局部变量中的引用，因为它们与用户代码的执行紧密相关。事实上这就意味着，参与操作 GC 引用的 <em>机器代码</em> 必须能够跟踪 GC 引用——也就是说，编译器需要生成额外的代码来完成这些工作。</p>\n<p>想要了解更多内容的话，请参看 <a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/garbage-collection.md\">垃圾回收器设计文档</a>。</p>\n<h3 id=\"什么是托管代码\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81\" aria-label=\"什么是托管代码 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是“托管代码”</h3>\n<p>这种能够做到“几乎随时”报告所有仍然生效的 GC 引用的代码，就叫做“托管代码”（因为它由 CLR 进行“托管”）。不满足这样的要求的代码就叫做非托管代码。因此所有在 CLR 启动之前执行的代码都是非托管代码，例如，所有的操作系统代码都是非托管的。</p>\n<h4 id=\"栈展开问题\" style=\"position:relative;\"><a href=\"#%E6%A0%88%E5%B1%95%E5%BC%80%E9%97%AE%E9%A2%98\" aria-label=\"栈展开问题 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>栈展开问题</h4>\n<p>很明显，由于托管代码需要使用操作系统提供的服务，有时托管代码就需要调用非托管代码。类似地，由于托管代码是由操作系统所启动的，因此有时非托管代码还会调用托管代码。因此，普遍来说，如果你在任意时刻暂停了某个托管程序，调用栈中将会混合着由托管代码和非托管代码创建的不同类型的栈帧。</p>\n<p>非托管代码所创建的栈帧只要满足程序能够运行就可以了。举例来说，这些栈帧并不需要支持查看谁调用了它们。这就是说，如果我们暂停了一个程序，它恰好正在执行非托管代码，那么并没有一种通用的方法能够知道调用者是谁[1]。虽然我们能够在调试器中看到调用者，但这是由于有额外的符号信息支持（PDB文件），而这种信息并不保证一定存在（这就是为什么在调试器里我们也经常拿不到完美的 Stack Trace）。对于托管代码来说，这绝对是个问题，因为栈里面很可能包含有托管代码的栈帧（托管代码的栈帧中包含了需要报告的 GC 引用）。</p>\n<p>对于托管代码来说，我们对它有一些附加要求：它不仅需要在执行时跟踪所有的 GC 引用，还必须能够回溯到它的调用者。除此之外，当我们从托管代码进入非托管代码的世界时（或者非托管代码调用托管代码也一样），托管代码必须进行额外的操作来绕过非托管代码无法进行栈展开的问题。在实践中，托管代码会把所有包含托管栈帧的内存块都互相连起来。因此，虽然我们还是没办法不借助调试信息来展开非托管栈帧，但是我们能够做到始终能够找到一块托管代码产生的栈内存，然后遍历所有的托管栈帧块。</p>\n<p>[1] 大多数最新的平台 ABI（Application Binary Interfaces）都定义了包含这种信息的约定，但通常并不是强制性的。</p>\n<h4 id=\"托管代码的世界\" style=\"position:relative;\"><a href=\"#%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%96%E7%95%8C\" aria-label=\"托管代码的世界 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>托管代码的世界</h4>\n<p>当每次进入、退出托管代码的世界时，就必须执行这种额外的机制。不论进入还是退出，CLR 都一定会知道。这两个世界泾渭分明（在任何时刻，代码要么在托管世界，要么在非托管世界）。更进一步，因为托管代码的执行基于一种 CLR 熟知的格式（以及使用<a href=\"http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf\">公共中间语言， CIL</a>），并且是 CLR 将其转换为能够在硬件上直接执行的指令，因此 CLR 能够做出比只是“执行” <em>多得多</em> 的操作。比如，CLR 能够改变“从一个对象中读取成员”或“调用一个函数”的意义。事实上，CLR 在创建 MarshalByReference 对象时就是这么做的。它们看起来像是普通的本地对象，但事实上它们可能保存于另一台机器上。简而言之，在CLR 的托管世界中存在大量的 <em>执行钩子</em>，它们可以用来实现非常强大的功能。我们下文会详细介绍。</p>\n<p>除此之外，托管代码还带来了另一个重要影响，虽然可能不那么明显。在非托管的世界，是没有 GC 指针的（因为它们无法被追踪），同时托管代码调用非托管代码还存在着额外的开销。这就意味着，虽然你 <em>可以</em> 调用任意的非托管代码，但这种体验不是很友好。非托管方法的参数和返回值并不包含 GC 对象，也就是说，它们所创建和使用的对象及对象句柄需要显示释放。同时，这些 API 还无法使用 CLR 所支持的功能（例如异常和继承），它们与托管代码在用户体验上并不统一。</p>\n<p>结果就是，非托管的接口在总是 <em>包装</em> 之后才提供给托管代码使用。例如，当访问文件的时候，你并不会直接使用操作系统提供的 Win32 CreateFile 函数，而是使用包装了文件操作的 System.IO.File 类。让用户直接使用非托管的功能确实非常少见。</p>\n<p>尽管这种包装看起来没什么好处（增加了很多没干什么事情的代码），但其实它们的价值非常大。我们总是 <em>可以</em> 直接使用非托管的接口，但我们 <em>选择了</em> 包装它们。为什么？因为运行时的终极目标是 <strong>使编程变得简单</strong>，通常来说非托管函数并不足够简单。常见的情况是，非托管的接口在设计时并没有时刻考虑易用性，而是优先满足完整性。如果你看过 CreateFile 或是 CreateProcess 的参数列表，你很难把他们归为“简单”那一类的接口。幸运的是，这些功能在托管世界中被“整容”了，尽管这种“整容”没什么技术难度（就是重命名、简化并重新组织相关功能），但仍然非常实用。CLR 最重要的文档之一就是 <a href=\"http://msdn.microsoft.com/en-us/library/ms229042.aspx\">Framework 设计指南</a>，这篇 800 多页的文档详细描述了创建新的托管类库的最佳实践。</p>\n<p>因此，我们可以看到，托管代码（与 CLR 紧密相连）与非托管代码在两方面有着显著的不同：</p>\n<ol>\n<li>\n<p>有技术含量的一面：托管代码有自己完全不同的世界，CLR 能够细粒度地控制程序执行的几乎每个方面（可能能够细到每一条指令），CLR 还能够检测到指令执行何时会进出托管世界。这使得很多有用的功能得以实现。</p>\n</li>\n<li>\n<p>没什么技术含量的一面：托管代码调用非托管代码时存在调用开销，非托管代码无法使用 GC 对象。因此，将非托管代码进行包装是一种推荐的方式。接口会被“整容”，从而变得简单，并能够统一命名和设计规范，提高一致性和可发现性。</p>\n</li>\n</ol>\n<p>这两点特性对于托管代码的成功都非常重要。</p>\n<h3 id=\"内存和类型安全\" style=\"position:relative;\"><a href=\"#%E5%86%85%E5%AD%98%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8\" aria-label=\"内存和类型安全 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>内存和类型安全</h3>\n<p>由垃圾收集器带来的一个不那么明显、但影响深远的特性是：内存安全。内存安全不变量（invariant）的要求非常简单：如果一个程序只访问已经申请（同时还未释放）的内存，那么它就是内存安全的。这意味着，不会有任何“野指针”（悬空指针）指向某个随机的内存地址（更准确地说，不会指向提前释放了的内存）。很显然，我们希望所有程序都能够做到内存安全。悬空指针就是 bug，调试这种 bug 通常有一些难度。</p>\n<blockquote>\n<p>GC 是提供内存安全保证的必要条件。</p>\n</blockquote>\n<p>显然，垃圾回收器消除了用户提前释放内存的可能性（从而不会访问到没有正确申请的内存）。不过，不那么明显的是：如果想要确保内存安全，从实践上讲我们必须要有一个垃圾收集器。原因在于，对于那些需要 <em>堆</em>（动态）内存申请的复杂程序，对象的生命周期基本上处于随意管理的状态（不像栈内存、或静态申请的内存，它们需要遵守高度受限的申请协议）。在这样的不受限的环境下，程序分析器无法确定需要在哪里插入显式的释放语句。实际上，决定何时释放内存的唯一途径就是在运行时确定。这其实就是 GC 的任务（检查某块内存是否仍然有效）。因此，任何需要在堆上进行内存申请的程序，如果想保证内存安全性，我们就 <em>需要</em> GC。</p>\n<p>GC 是保证内存安全的必要条件，但不充分。GC 并不会禁止程序越界访问数组，或是越界访问一个对象的成员（如果你通过基地址和偏移来计算成员地址的话）。不过，如果我们有办法解决这些问题，我们就能够实现内存安全的程序。</p>\n<p><a href=\"http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf\">公共中间语言</a>（CIL）<em>确实</em> 提供了一些操作符，它们可以用来在任意内存上读取和写入数据（因此破坏了内存安全性），不过他还提供了下面这些内存安全的操作符，CLR 也强烈建议在大多数的情况下使用它们：</p>\n<ol>\n<li>\n<p>字段访问操作符（LDFLD、STFLD、LDFLDA），它们能够通过名字来读取、写入一个字段，以及获取一个字段的地址。</p>\n</li>\n<li>\n<p>数组访问操作符（LDELEM、STELEM、LDELEMA），它们能够通过数据索引来读取、设置数组元素，以及获取数组元素的地址。所有的数组都有一个标签，写明了数组的长度。在每次访问数组元素时，都会自动进行边界检查。</p>\n</li>\n</ol>\n<p>使用这些操作符来取代那些低级的（同时也是不安全的）内存访问操作符，同时避免使用其他的不安全的 CIL 操作符（例如有一些操作符支持跳转到任意地址），这样的话我们就可以创建一个内存安全的系统了。但是，仅此而已。CLR 没有选择这条路；相反，CLR 选择了确保一个更强的不变量：类型安全。</p>\n<p>对于类型安全来说，从概念上讲，每一块申请的内存都将与一种类型相关联。所有在内存地址上的操作都将在概念上使用有效的类型进行标记。类型安全需要保证的是，某一块标记了某一种特定类型的内存，只能够进行这种类型允许的操作。这不仅确保了内存安全（没有悬空指针），同时它还对不同的类型提供了额外的保证。</p>\n<p>在这些与类型相关的保证当中，最重要的保证之一就是（与字段相关联的）可见性控制属性（Attribute）。如果一个字段声明为 private（仅能够由这个类型中的方法所访问），那么这种限制就会被所有其他的类型安全的代码所遵守。例如，某个类型可能会声明一个名为 count 的字段，它代表了一张表里面对象的个数。假设这个 count 和这张表都是 private 的，同时我们假定代码一定会同时把这两个成员一起更新，那么现在我们就有了一个强保证：在所有类型安全的代码中，count 和这张表中的对象个数是一致的。当我们编写程序时， 不论程序员知道与否，他们无时无刻都在利用着类型安全的概念。CLR 将类型安全由编程语言/编译器之间的简单约定，提升到可以在运行时也严格执行的强制约定。</p>\n<h4 id=\"可验证代码强制内存安全和类型安全\" style=\"position:relative;\"><a href=\"#%E5%8F%AF%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81%E5%BC%BA%E5%88%B6%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8\" aria-label=\"可验证代码强制内存安全和类型安全 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>可验证代码——强制内存安全和类型安全</h4>\n<p>从概念上说，为了保证类型安全，我们需要对程序的每一个操作进行检查，以便确保目标内存的类型是否与这种操作兼容。尽管我们可以做到这一点，但可想而知肯定非常慢。在 CLR 中，我们有 “CIL 验证”的概念，在代码运行之前，我们会对 CIL 进行一次静态分析，进而确保大多数操作都是类型安全的。只有当这种静态分析无法满足需求时，运行时检查才有必要。在实践当中，需要运行时检查的情况其实并不多见，其中包括：</p>\n<ol>\n<li>\n<p>将一个指向基类的指针转换为指向子类的指针（相反的操作可以进行静态检查）</p>\n</li>\n<li>\n<p>数组边界检查</p>\n</li>\n<li>\n<p>将指针数组中的一个元素赋值为一个新的（指针）值。需要这种检查的原因是，CLR 的数组支持自由转换规则（后文会详细介绍）</p>\n</li>\n</ol>\n<p>需要注意的是，运行时需要额外的特性来满足这些检查的需要：</p>\n<ol>\n<li>\n<p>所有在 GC 堆上的内存必须标记其类型（以便转换操作能够执行）。它的类型信息在运行时必须能够获得，而且必须包含足够的信息来确定类型转换是否合法（例如，运行时需要知道继承结构）。事实上，GC 堆中的每一个对象的第一个字段都指向一个表示其类型的数据结构。</p>\n</li>\n<li>\n<p>所有的数组必须包含它的大小（以便进行边界检查）</p>\n</li>\n<li>\n<p>数组必须包含它的元素类型的完整类型信息</p>\n</li>\n</ol>\n<p>幸运的是，大多数看起来昂贵的要求（例如为每一个堆对象标记类型）已经是为了实现垃圾回收所必须的条件了（例如 GC 需要知道每个对象中需要扫描的字段），因此类型安全所带来的额外开销并没有多少。</p>\n<p>因此，验证了代码的 CIL，又做了一些运行时检查，CLR 能够确保类型安全（以及内存安全）。然而，这种额外的安全需要在编程的灵活性上做出一点牺牲。CLR 提供了通用的内存访问操作符，但为了让代码可以验证，这些操作符的使用需要收到一定的限制。具体来说，目前所有的指针算术计算都会让验证失败，因此很多经典的 C/C++ 约定无法在可验证代码中使用；我们必须使用数组来替代。不过虽然这限制了一点编程的灵活性，但它并不是件坏事（数组很强大），带来的好处也很明显（烦人的 Bug 少了很多）。</p>\n<p>CLR 机器鼓励使用可验证的、类型安全的代码。尽管如此，还是有时候需要不可验证的程序（主要是与非托管代码打交道时）。CLR 是允许这样的情况的，但最好把这样的代码尽可能的加以限制。常见的程序只需要一小块不安全的代码，其余的代码都可以是类型安全的。</p>\n<h3 id=\"高级特性\" style=\"position:relative;\"><a href=\"#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7\" aria-label=\"高级特性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>高级特性</h3>\n<p>支持垃圾回收给运行时带来了很大的影响，因为他要求所有的代码必须支持额外的跟踪记录。我们对类型安全的期望同样给运行时带来了很大的影响，不仅要求程序的描述（即 CIL）支持字段和方法附带详细的类型信息，还要求它对其他的类型安全的高级编程语言结构提供支持。以类型安全的方式来表达这些结构同样需要运行时的支持。这两点重要的高级特性用来支持面向对象编程中最基础的两个要素：继承和虚调用分发。</p>\n<h4 id=\"面向对象编程\" style=\"position:relative;\"><a href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B\" aria-label=\"面向对象编程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>面向对象编程</h4>\n<p>从机械的角度来讲，继承相对简单一些。它的基本思想是：如果 <code class=\"language-text\">derived</code> 类型的字段是 <code class=\"language-text\">base</code> 类型的字段的超集，那么只要将 <code class=\"language-text\">derived</code> 字段中的 <code class=\"language-text\">base</code> 那一部分字段放在前面，那么所有接受 <code class=\"language-text\">base</code> 指针的代码都能够接受 <code class=\"language-text\">derived</code> 对象，这样代码依然能够工作。这样的话，我们就说 <code class=\"language-text\">derived</code> 是继承自 <code class=\"language-text\">base</code>，代表着它能够在任何需要 <code class=\"language-text\">base</code> 的地方使用。这样的话，代码就变得 <em>多态</em>，因为同样的代码作用于很多不同的类型。由于运行时需要知道什么样的类型转换是合法的，因此运行时必须形式化它所支持的“继承”，以便能够对类型安全进行验证。</p>\n<p>虚调用分发泛化了继承多态。它允许基类型声明某个方法能够被子类所 <em>重载</em>。使用 <code class=\"language-text\">base</code> 类型的代码可以调用虚方法，这些调用会在运行时根据对象的真实类型分发至正确的重载方法。这种 <em>运行时的分发逻辑</em> 可以不需要运行时的直接支持，而是使用基本的 CIL 指令来实现，但这样做有两点很重要的弊端：</p>\n<ol>\n<li>\n<p>这样做可能有违类型安全（分发表一旦出错，将会带来灾难性的后果）</p>\n</li>\n<li>\n<p>每个面向对象语言可能会使用一些稍微不同的方法来实现它的虚分发逻辑。结果就是，这些语言之间的互操作性受到了影响（在一门语言中无法继承由另一门语言实现的基类）</p>\n</li>\n</ol>\n<p>正因如此，CLR 对基本的面向对象特性提供了直接支持。CLR 在最大的程度上尽量保证它的继承模型“语言中立”，因为不同语言之间仍然有可能共享相同的继承结构。然而，这并不是一定能够实现的。具体来说，多重继承可以通过很多种方式来实现。CLR 的选择是：不支持那些带有字段的类型的多重继承，但支持一些不含有字段的特殊类型（即 interface）的多重继承。</p>\n<p>值得注意的是，尽管运行时支持这些面向对象的概念，我们并不需要一定使用它们。没有继承概念的语言（例如函数式语言）只需要简单地抛弃这些特性就好了。</p>\n<h4 id=\"值类型和装箱boxing\" style=\"position:relative;\"><a href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%A3%85%E7%AE%B1boxing\" aria-label=\"值类型和装箱boxing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>值类型和装箱（Boxing）</h4>\n<p>在面向对象编程中，一个深远又微妙的影响是对象标识：我们能够区分出通过不同的内存申请调用产生的不同对象，就算是两个对象中的所有字段全部相等也没关系，这是由于对象使用的是引用（指针）而不是通过值来进行访问的。如果两个变量持有同一个对象（他们的指针指向同样的内存），那么更新某一个变量就会影响到另一个变量。</p>\n<p>然而，这种对象标识的概念并不是对所有的类型都合适。举例来说，大多数程序员不会把整数看作是对象。如果在两个不同的地方申请了数字“1”，程序员通常会希望这两个东西相等，并且不想要更新某一个时影响另一个。事实上，有一大类编程语言（函数式语言）就在极力避免“对象标识”与引用语义。</p>\n<p>尽管我们额能够做出一个“纯”面向对象系统，其中所有的东西（包括整数）都是一个对象（就像 Smalltalk-80 一样），但在这一层统一性下面，我们还是由很多工作要做，才能够得到一种高效的实现。其他的语言（比如 Perl、Java、Javascript）采用了一种实用的方法，它们讲某些类型（例如整型）看作是值类型，其他的类型使用引用类型。CLR 同样选择了一种混合模型，但区别在于，它允许用户自定义值类型。</p>\n<p>值类型的关键特点在于：</p>\n<ol>\n<li>\n<p>每一个值类型的局部变量、字段和数组元素都包含了值的独有拷贝。</p>\n</li>\n<li>\n<p>当一个变量、字段或者数组元素进行赋值操作时，值会被拷贝。</p>\n</li>\n<li>\n<p>相等性永远使用变量中的数据进行定义（而不是它的地址）。</p>\n</li>\n<li>\n<p>每一个值类型都有一个对应的引用类型，这个引用类型只有一个隐式的、未命名的字段。这叫做这个值类型的装箱值（boxed value）。装箱值类型可以参与继承，并且拥有对象标志（不过非常不推荐使用一个装箱值类型的对象标志）。</p>\n</li>\n</ol>\n<p>值类型与 C（和 C++）中的结构体有些相似。像 C 一样，你可以使用指针指向值类型，但这个指针类型与结构体的类型是不同的。</p>\n<h4 id=\"异常\" style=\"position:relative;\"><a href=\"#%E5%BC%82%E5%B8%B8\" aria-label=\"异常 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>异常</h4>\n<p>另一个 CLR 直接支持的高级语言结构是异常。异常允许程序员在发生错误时 <em>抛出</em> 一个任意的对象。当这个对象被抛出时，运行时就会搜索调用栈，去寻找是否有哪个方法声明了它可以 <em>捕捉</em> 这个异常。如果这样的捕捉声明存在，程序就继续从捕捉声明这里执行。异常的用途在于它规避了程序员忘记检查某个方法是否成功。异常有助于程序员规避错误（因而使得编程变得简单），因此 CLR 支持它们也就不奇怪了。</p>\n<p>尽管异常能够避免这类常见错误，但它们无法解决另一类问题：在异常发生时，如何将数据恢复至一致的状态。这就是说，在异常被捕获之后，很难讲如果继续执行的话会不会发生（由第一次的错误而引起的）其他的错误。这一方面是 CLR 在未来值得拓展的地方。不过就目前来说，异常仍然是向前迈出的一大步（我们还需要走得更远）。</p>\n<h4 id=\"参数化类型泛型\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E6%B3%9B%E5%9E%8B\" aria-label=\"参数化类型泛型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参数化类型（泛型）</h4>\n<p>在 CLR 2.0 版本之前（译注：非 CoreCLR），数组是唯一一个参数化的类型。所有的其他容器（比如哈希表、列表、队列等等）都操作于通用的 Object 类型之上。无法创建一个 <code class=\"language-text\">List&lt;T></code> 或者 <code class=\"language-text\">Dictionary&lt;KeyT, ValueT></code> 在性能上会有所劣势，因为这些类型都需要在容器的接口处进行装箱，并在取出元素时进行显式类型转换。然而，这些都不是 CLR 加入参数化类型的根本原因。最主要的原因是， <strong>参数化类型能够使编程变得更简单</strong>。</p>\n<p>想知道原因的话，我们可以想象一下，一个只使用通用的 Object 类型的类库是什么样子的，这与那些动态类型语言（比如 Javascript） 很像。在这种情况下，程序员有非常容易写出不正确（但是类型安全）的程序。这个方法的参数应该是一个列表吗？一个字符串？还是一个整数？从方法的签名就很难得到答案。更糟糕的是，当一个方法返回了一个 Object，哪些方法可以接受它作为参数？通常来说，一个框架可能有成百上千种方法；如果它们所有的参数都是 Object 类型，就很难判断哪些 Object 对象是这个方法所需要的。简而言之，强类型能够帮助程序员更清晰地表达出他的意图，同时还允许工具（例如编译器）来确保他的意图一定会实现。这样就极大地提升了生产力。</p>\n<p>当我们谈到列表和字典等容器时，这些优点仍然成立，因此参数化类型是非常有价值的。下面需要考虑的问题是，我们是选择把参数化类型作为一门语言的一项特性，然后在编译时将这一层概念抹掉，还是说应该作为运行时的一等公民提供支持？其实哪一种实现都可以，CLR 团队选择了一等公民支持。原因在于，不这样的话，每一种语言都可能会有不同的参数化类型的实现方式。这就意味着互操作也会变得麻烦起来。最重要的是，使用参数化类型来表达程序员的意图尤其在类库的 <em>接口上</em> 非常有用。如果 CLR 不正式支持参数化类型，那么类库就无法使用它们，就会丢掉这条特性的一个重要的使用场景。</p>\n<h4 id=\"程序即数据反射-api\" style=\"position:relative;\"><a href=\"#%E7%A8%8B%E5%BA%8F%E5%8D%B3%E6%95%B0%E6%8D%AE%E5%8F%8D%E5%B0%84-api\" aria-label=\"程序即数据反射 api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>程序即数据（反射 API）</h4>\n<p>CLR 的基础功能是垃圾回收、类型安全、以及高级语言特性。这些基础的特性使得 CIL 需要在一个相对高级的层次制定规范。在运行时，我们能够得到非常丰富的信息（相反，C 或 C++ 程序就不存在），把它们暴露给程序员使用就非常有价值。这样的想法催生了 System.Reflection 接口（之所以叫做反射是因为这些接口允许程序（通过自己的反射）看到自己）。这一套接口允许我们探索一个程序的绝大部分方面（例如它都有哪些类型、继承关系、拥有哪些方法和字段）。事实上，由于只有很少的信息丢失，托管代码拥有一些非常好的“反编译器”（例如 <a href=\"http://www.red-gate.com/products/reflector/\">NET Reflector</a>）。尽管在知识产权保护方面可能会让人感到忧虑（但其实我们可以通过一种叫做 <em>混淆</em> 的方式有意擦除这些信息），但这也恰好证明了，托管代码在运行时仍然拥有很丰富的信息。</p>\n<p>除了在运行时检视程序外，我们还能够对其进行一些操作（例如调用方法、设置字段等等），而最强大的功能可能是在运行时从零开始生成代码（System.Reflection.Emit）。事实上，运行时类库使用这种方式来创建匹配字符串的特化代码（System.Text.RegularExpressions），以及创建用来“序列化”对象（使得对象能够存于文件或在网络上传输）的代码。这在以前是办不到的（你需要写一个编译器！），但是 CLR 所提供的这类能力使得很多编程问题变得更加容易解决。</p>\n<p>尽管反射功能确实非常强大，但在使用上需要小心。反射要比静态编译出的代码慢上很多，而更重要的是，自我引用的系统更加难以理解。也就是说，只有当应用价值非常大、需求非常明确时，才应该使用 Reflection 或 Reflection.Emit。</p>\n<h2 id=\"其他功能\" style=\"position:relative;\"><a href=\"#%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD\" aria-label=\"其他功能 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>其他功能</h2>\n<p>最后要介绍的运行时功能与 CLR 的基础架构（GC、类型安全、高级规范）无关，但仍然时任何完备的运行时系统都需要拥有的特性。</p>\n<h3 id=\"与非托管代码的交互\" style=\"position:relative;\"><a href=\"#%E4%B8%8E%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BA%A4%E4%BA%92\" aria-label=\"与非托管代码的交互 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>与非托管代码的交互</h3>\n<p>托管代码需要使用非托管代码中的功能。CLR 提供两种不同“口味”的交互方法，一种是直接调用非托管函数（叫做 Platform Invoke，PINVOKE）；除此之外，非托管代码同样有一种面向对象的交互模型，名曰 COM（Component Object Model），与 Ad-Hoc 方法调用相比，他更加结构化一些。由于 COM 同样拥有对象模型和其他约定（例如错误是如何处理的、对象的声明周期等），在有特别支持的情况下，CLR 与 COM 之间的交互会更容易。</p>\n<h3 id=\"提前编译ahead-of-time\" style=\"position:relative;\"><a href=\"#%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91ahead-of-time\" aria-label=\"提前编译ahead of time permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>提前编译（Ahead of Time）</h3>\n<p>在 CLR 的模型中，托管代码以 CIL 的形式分发，而不是原生代码。CLR 在运行时将 CIL 翻译为原生代码。作为一种优化，可以使用 crossgen 工具（类似于 .NET Framework 中的NGEN）将 CIL 转化为原生代码，并保存下来。这能够在运行时节省大量的编译时间。由于类库的规模十分庞大，这一功能非常重要。</p>\n<h3 id=\"多线程\" style=\"position:relative;\"><a href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\" aria-label=\"多线程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>多线程</h3>\n<p>CLR 非常重视托管代码对与多线程的需求。从一开始，CLR 类库就包含了 System.Threading.Thread 类，它是对操作系统线程的 1 对 1 的包装。然而，正因为它是对操作系统线程的包装，创建一个 System.Threading.Thread 相对昂贵（需要花费数毫秒来启动）。对于很多操作来说这也许够了，但有时程序需要创建一些很小的工作任务（比如只需要花费数十毫秒）。这在服务器编程上很常见（例如，每一个任务都只服务于一个网页），在需要利用多处理器的算法种也很常见（例如多核排序算法）。为了支持这些场景，CLR 还提供了 ThreadPool 的概念，用来完成一个个工作任务，同时由 CLR 负责创建这些必要的线程。尽管 CLR 确实直接暴露了 ThreadPool（System.Threading.ThreadPool 类），但推荐使用的机制是 <a href=\"https://msdn.microsoft.com/en-us/library/dd460717(v=vs.110).aspx\">Task Parallel Library</a>，它提供了对常见的并发控制的额外支持。</p>\n<p>从实现的角度来说，ThreadPool 的创新之处在于是由 CLR 负责确定合理的工作线程数目。CLR 使用了一种反馈系统，它监视着吞吐率与线程的数量，并调整线程的数量以便最大化吞吐量。这能够让程序员直接关注于使用并发（即创建工作任务），而不是去先思考如何设置正确的并发量（这取决于工作负载和硬件）。</p>\n<h2 id=\"总结和资源\" style=\"position:relative;\"><a href=\"#%E6%80%BB%E7%BB%93%E5%92%8C%E8%B5%84%E6%BA%90\" aria-label=\"总结和资源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结和资源</h2>\n<p>啊~！运行时实在是做了太多事了！我们花了很长的篇幅，只介绍了运行时的 <em>部分</em> 功能，也还没有深入内部细节。我希望，这篇介绍性文章能够帮助你对这些内部实现有一个更深的理解。这篇文章介绍过的内容有：</p>\n<ul>\n<li>CLR 运行时是用来支持编程语言的一整套框架</li>\n<li>运行时的目的是让编程变得简单</li>\n<li>运行时的首要功能为：\n<ul>\n<li>垃圾回收</li>\n<li>内存安全和类型安全</li>\n<li>对高级语言功能的支持</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"值得一看的链接\" style=\"position:relative;\"><a href=\"#%E5%80%BC%E5%BE%97%E4%B8%80%E7%9C%8B%E7%9A%84%E9%93%BE%E6%8E%A5\" aria-label=\"值得一看的链接 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>值得一看的链接</h3>\n<ul>\n<li><a href=\"http://msdn.microsoft.com/library/8bs2ecf4.aspx\">MSDN 上关于 CLR 的页面</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Common_Language_Runtime\">Wikipeida 上关于 CLR 的页面</a></li>\n<li><a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md\">CLI 的 ECMA 标准</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ms229042.aspx\">.NET Framework 设计指南</a></li>\n<li><a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/README.md\">CoreCLR 仓库文档</a></li>\n</ul>"},"childMdx":null}},{"node":{"id":"d3ade90e-e8e2-5d2a-9d2a-70dbcac8504b","relativePath":"botr/2-garbage-collection.md","childMarkdownRemark":{"fields":{"slug":"/botr/2-garbage-collection/"},"frontmatter":{"title":"二、CLR 垃圾回收器的设计"},"html":"<blockquote>\n<p>这是一篇译文。作者：Maoni Stephens (@maoni0) - 2015<br>\n原文链接：<a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/garbage-collection.md\">https://github.com/dotnet/coreclr/blob/master/Documentation/botr/garbage-collection.md</a></p>\n</blockquote>\n<p>注：请参考 The Garbage Collection Handbook 来了解更多关于垃圾回收话题的通用知识；如果希望了解关于 CLR GC 的特定知识，请参考 Pro .NET Memory Management 一书。在本文最后列出了其他可供参考的资源。</p>\n<h2 id=\"整体结构\" style=\"position:relative;\"><a href=\"#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84\" aria-label=\"整体结构 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>整体结构</h2>\n<p>CLR GC 由两部分组成：分配器和回收器。分配器用来申请更多的内存，并在合适的时机触发垃圾回收。回收器收集内存垃圾，即程序不再使用的那些对象所占用的内存。</p>\n<p>除了分配器，还有其他的途径能够触发回收器，例如手动调用 GC.Collect，或是 Finalizer 线程收到了 LowMemory 的异步通知。</p>\n<h2 id=\"分配器的设计\" style=\"position:relative;\"><a href=\"#%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1\" aria-label=\"分配器的设计 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>分配器的设计</h2>\n<p>分配器由执行引擎（Execution Engine，EE）通过一些帮助函数进行调用，会传递给分配器以下信息：</p>\n<ul>\n<li>申请的内存大小</li>\n<li>线程分配上下文</li>\n<li>标志位，例如标记这个对象是否 Finalizable</li>\n</ul>\n<p>分配器并不关心对象类型的信息，它只会通过 EE 得到对象的大小。基于对象大小，GC 会将对象分为两类：小对象（小于 85000 字节）和大对象（大于等于 85000 字节）。理论上来说，大对象、小对象不需要区别对待，但由于对大对象进行整理（Compact）的代价较大，因此 GC 会做出这样的区分。</p>\n<p>分配器会向 GC 申请内存。GC 会以分配上下文（Allocation Context）的形式向分配器提供内存，分配上下文的大小由分配量（Allocation Quantum）决定。</p>\n<ul>\n<li>所谓分配上下文，是指一个堆内存段（Heap Segment）上的一小部分，将会由某个线程单独使用。在单一逻辑处理器的机器上，只会使用唯一一个上下文，作为第 0 代分配上下文。</li>\n<li>所谓分配量，是指当分配器需要更多的内存来创建对象时，它每次获得的新内存空间的大小。分配量通常定义为 8k 字节，而托管对象的平均大小大约为 35 字节，这使得分配器能够在一个分配上下文中创建很多个对象。</li>\n</ul>\n<p>大对象不使用分配上下文和分配量，它们本身就可能要比常规的分配量大得多；同时，分配上下文的优势仅能在小对象中体现出来。因此，大对象会直接在堆内存段上申请。</p>\n<p>分配器的特点包括：</p>\n<ul>\n<li>在合适的时机触发垃圾回收：当分配的内存大小超过一定分配额度（Allocation Budget）之后、或是分配器在一个堆内存段上没有内存可用的时候，它就会触发一次垃圾回收。关于分配额度和托管段（Managed Segment），后文还会详细介绍。</li>\n<li>保持对象局部性：在同一个对内存段上的对象，它们的虚拟地址会依次相邻。</li>\n<li>高效利用缓存：分配器每次会一次性申请分配量大小的内存，而不是每个对象都来申请一次内存。它会把这些缓存都清零，从而使得 CPU 能够预先缓存这块内存。</li>\n<li>减少加锁需求：由于一个分配上下文和分配量只由一个线程使用，因此只要当前的分配上下文没有耗尽，就无需加锁。</li>\n<li>内存完整性：GC 总是会为新对象清零内存，因此不会存在指向随机地址的对象引用。</li>\n<li>保证堆内存可被爬取：分配器会保证每一个分配量中无法分配的剩余内存作为一个空闲对象（Free Object）管理。例如，如果一个分配量只剩下 30 字节的空间，但新对象需要 40 字节，那么分配器会创建一个 30 字节大小的空闲对象（译注：空闲对象会加入空闲列表中进行管理，从而不会白白浪费），同时申请一个新的分配量大小的内存来分配新的对象。</li>\n</ul>\n<h3 id=\"内存分配-api\" style=\"position:relative;\"><a href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-api\" aria-label=\"内存分配 api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>内存分配 API</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\"> Object* GCHeap::Alloc(size_t size, DWORD flags);\n Object* GCHeap::Alloc(alloc_context* acontext, size_t size, DWORD flags);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>大对象和小对象在分配内存均可以使用上面的函数。除此之外，大对象的分配还会使用下面这个函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\"> Object* GCHeap::AllocLHeap(size_t size, DWORD flags);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"回收器的设计\" style=\"position:relative;\"><a href=\"#%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1\" aria-label=\"回收器的设计 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>回收器的设计</h2>\n<h3 id=\"gc-的目标\" style=\"position:relative;\"><a href=\"#gc-%E7%9A%84%E7%9B%AE%E6%A0%87\" aria-label=\"gc 的目标 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC 的目标</h3>\n<p>GC 的目标是极度高效地管理内存，使得编写“托管代码”的人几乎不需要付出额外的成本即可受益。“高效”指的是：</p>\n<ul>\n<li>GC 的执行频率需要足够高。这可以避免托管堆中残留大量的无用对象（即垃圾），而导致占用过多不必要的内存。</li>\n<li>GC 的执行频率需要尽量低。这可以避免浪费宝贵的 CPU 时间。</li>\n<li>一次 GC 需要很有效。如果一次 GC 后几乎没有回收到内存，那么这次 GC（以及它所占用的 CPU 时间）就被浪费了。</li>\n<li>每次 GC 都需要很快。很多程序有低延迟的需求。</li>\n<li>托管代码的开发人员不需要知道 GC 的细节就可以享受到不错的内存使用率。也就是说，GC 应该自行调节，以便使用不同的内存使用模式。</li>\n</ul>\n<h3 id=\"托管堆的逻辑表示\" style=\"position:relative;\"><a href=\"#%E6%89%98%E7%AE%A1%E5%A0%86%E7%9A%84%E9%80%BB%E8%BE%91%E8%A1%A8%E7%A4%BA\" aria-label=\"托管堆的逻辑表示 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>托管堆的逻辑表示</h3>\n<p>CLR GC 是一个分“世代”的垃圾回收器，即对象在逻辑上会被分为不同的世代。当回收器回收了第 N 代后，仍然存活的对象将被标记为第 N + 1 代，这个过程叫做升级（Promotion）。不过，这里也存在例外，比如我们可能会考虑让某个对象不升级或者降级（demote）。</p>\n<p>对于小对象来说，托管堆被分为 3 个世代：gen0、gen1 和 gen2。对于大对象来说，我们只有一个世代—— gen3。gen0 和 gen1 统称为短暂世代（Ephemeral Generations），代表着这两个世代中的对象存活时间较短。</p>\n<p>小对象堆中的世代编号就代表了辈分—— gen0 是最年轻的世代。不过，这并不意味着 gen0 中的所有对象都要比 gen1 或者 gen2 中的对象更年轻，下文会提到一些例外的情况。当我们对某一个世代进行垃圾回收时，也会同时回收所有比它年轻的世代。</p>\n<p>从理论上讲，大对象的处理方式也可以像小对象一样。然而，由于整理（Compact）大对象的代价比较高，因此我们将大小对象区别对待。大对象只有一个世代 gen3，考虑到性能原因，它会与 gen2 一同进行垃圾回收，因为 gen2、gen3 世代相对庞大；而短暂世代（gen0、gen1）中的对象往往生存期短，对它们进行回收时则会尽量限制性能开销。</p>\n<p>分配内存时，会从最年轻的世代开始——对于小对象来说就是 gen0，大对象来说就是 gen3。</p>\n<h3 id=\"托管堆的物理表示\" style=\"position:relative;\"><a href=\"#%E6%89%98%E7%AE%A1%E5%A0%86%E7%9A%84%E7%89%A9%E7%90%86%E8%A1%A8%E7%A4%BA\" aria-label=\"托管堆的物理表示 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>托管堆的物理表示</h3>\n<p>托管堆由一组托管堆段组成。一个堆段是一块连续的内存，它是由 GC 向操作系统申请而得。堆段分为两种：小对象堆段和大对象堆段。在每一个堆上，堆段之间会以链式连接。一个程序的内存中至少会存在一个小对象堆段和一个大对象堆段，这两个堆段会在 CLR 启动时被默认建立。</p>\n<p>在每一个小对象堆中，仅会有一个堆段用来存放 gen0 和 gen1，它叫做“短暂世代堆段”。这个堆段也可以同时用来存放 gen2。除了这个堆段之外，还可能会有一个或多个段用来存放 gen2。</p>\n<p>大对象堆中也可能会有多个堆段。</p>\n<p>一个堆段会以地址“从低到高”的方式进行使用，也就是说，低地址上的对象要比高地址上的对象更老。当然，下文会提到一些例外情况。</p>\n<p>堆段可以按需申请。如果一个堆段不包含任何任何对象，那么它就会被删除。不过，一个堆中的初始堆段是个例外，它会始终存活。对于每个堆来说，小对象的垃圾回收、或者大对象的内存分配，都有可能会触发新的堆段申请，每次只会申请一个新堆段。这样的设计能够提供更好的性能，因为大对象会与 gen2 一同进行回收，比较耗时。</p>\n<p>堆段会按照它们的申请时间依次相连。最后的堆段一定是短暂世代堆段。对于小对象堆来说，没有对象的堆段可以重复利用，作为新的短暂世代堆段。小对象在申请内存时，只会在短暂世代堆段上进行；而大对象在申请内存时，则会在整个大对象堆上进行。</p>\n<h3 id=\"分配额度allocation-budget\" style=\"position:relative;\"><a href=\"#%E5%88%86%E9%85%8D%E9%A2%9D%E5%BA%A6allocation-budget\" aria-label=\"分配额度allocation budget permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>分配额度（Allocation Budget）</h3>\n<p>分配额度是与世代相关的一个逻辑概念，它是触发在这一世代上进行垃圾回收的阈值。这个额度的设置与这一世代的存活率有关。如果存活率较高，那么分配额度也将设置的更高，这样当下次垃圾回收时就能够回收到更多的垃圾。</p>\n<h3 id=\"如何决定对哪一个世代进行回收\" style=\"position:relative;\"><a href=\"#%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E5%AF%B9%E5%93%AA%E4%B8%80%E4%B8%AA%E4%B8%96%E4%BB%A3%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%94%B6\" aria-label=\"如何决定对哪一个世代进行回收 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>如何决定对哪一个世代进行回收</h3>\n<p>当触发了垃圾回收时，垃圾回收器要做的第一件事就是确定回收哪一个世代。除了分配额度，还有其他的因素需要考虑：</p>\n<ul>\n<li>世代的碎片化程度——如果一个世代的碎片化程度很高，那么在这个世代上进行垃圾回收将会更富有成效。</li>\n<li>当机器的内存负载很高时，如果回收某一世代有可能能够释放内存空间，那么垃圾回收器会更加激进地进行回收。这对避免比不要的（跨机器）分页很重要。</li>\n<li>如果短暂对象堆段空间不足时，垃圾回收器会更加激进地对 gen1 进行回收，来避免申请一个新的堆段。</li>\n</ul>\n<h2 id=\"垃圾回收的流程\" style=\"position:relative;\"><a href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%B5%81%E7%A8%8B\" aria-label=\"垃圾回收的流程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>垃圾回收的流程</h2>\n<h3 id=\"标记mark阶段\" style=\"position:relative;\"><a href=\"#%E6%A0%87%E8%AE%B0mark%E9%98%B6%E6%AE%B5\" aria-label=\"标记mark阶段 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>标记（Mark）阶段</h3>\n<p>标记阶段的目标是找到所有的存活对象。</p>\n<p>分世代的垃圾回收器的优势之一在于，它可以只对堆中的一部分对象进行回收，而不是去一次性考虑所有的对象。当回收短暂世代时，垃圾回收器需要知道这些时代中哪些对象仍然有效。执行引擎能提供它持有的所有对象的信息；然而，更老世代中的对象也可能持有年轻世代中的对象引用。</p>\n<p>垃圾回收器通过利用“卡片”（Card）标记，来更快地确定更老世代中的对象是否持有年轻世代中某个对象的引用。卡片由 JIT 帮助方法在赋值操作发生时进行设置。当 JIT 帮助方法发现一个了短暂世代中的对象被其他对象持有时，它将会设置短暂对象中相应的卡片字节以便标记引用源的大致位置。在回收短暂世代的过程中，垃圾回收器可以通过对象的卡片标记值来有选择地扫描内存，而不是把所有的内存都扫描一遍。</p>\n<h3 id=\"计划plan阶段\" style=\"position:relative;\"><a href=\"#%E8%AE%A1%E5%88%92plan%E9%98%B6%E6%AE%B5\" aria-label=\"计划plan阶段 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>计划（Plan）阶段</h3>\n<p>计划阶段模拟了一次整理（Compact）过程，用来确定对这一世代是否需要整理。如果不需要的话，垃圾回收器则会执行清扫（Sweep）。</p>\n<h3 id=\"重定位relocate阶段\" style=\"position:relative;\"><a href=\"#%E9%87%8D%E5%AE%9A%E4%BD%8Drelocate%E9%98%B6%E6%AE%B5\" aria-label=\"重定位relocate阶段 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>重定位（Relocate）阶段</h3>\n<p>如果垃圾回收器决定进行整理，那么被整理的对象的位置将会发生改变，因此必须要更新这些对象的引用。重定位阶段需要找到被回收世代中对象的所有引用。与之相比，标记阶段只需要找到那些会影响对象生命周期的引用，而不必考虑弱引用。</p>\n<h3 id=\"整理compact阶段\" style=\"position:relative;\"><a href=\"#%E6%95%B4%E7%90%86compact%E9%98%B6%E6%AE%B5\" aria-label=\"整理compact阶段 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>整理（Compact）阶段</h3>\n<p>这个阶段比较简单。由于在计划阶段已经计算好了那些需要移动的对象的新位置，整理阶段只需要将它们拷贝到目标地址即可。</p>\n<h3 id=\"清扫sweep阶段\" style=\"position:relative;\"><a href=\"#%E6%B8%85%E6%89%ABsweep%E9%98%B6%E6%AE%B5\" aria-label=\"清扫sweep阶段 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>清扫（Sweep）阶段</h3>\n<p>清扫阶段会找出那些夹在存活对象之间的垃圾空间，垃圾回收器会创建一个“自由对象”（Free Object）来占据这些空间，相邻的垃圾空间也会被合并进一个自由对象。这些自由对象会被放入自由对象列表 <code class=\"language-text\">freelist</code> 中。</p>\n<h2 id=\"代码流程\" style=\"position:relative;\"><a href=\"#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B\" aria-label=\"代码流程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>代码流程</h2>\n<p>术语：</p>\n<ul>\n<li>WKS GC：Workstation GC</li>\n<li>SVR GC：Server GC</li>\n</ul>\n<h3 id=\"各种配置下的行为\" style=\"position:relative;\"><a href=\"#%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E8%A1%8C%E4%B8%BA\" aria-label=\"各种配置下的行为 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>各种配置下的行为</h3>\n<h4 id=\"wks-gc关闭并发-gc\" style=\"position:relative;\"><a href=\"#wks-gc%E5%85%B3%E9%97%AD%E5%B9%B6%E5%8F%91-gc\" aria-label=\"wks gc关闭并发 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>WKS GC，关闭并发 GC</h4>\n<ol>\n<li>用户线程的分配额度不足，触发了垃圾回收</li>\n<li>垃圾回收器调用 <code class=\"language-text\">SuspendEE</code> 来暂停托管线程</li>\n<li>垃圾回收器决定对哪个世代进行回收</li>\n<li>执行标记阶段</li>\n<li>执行计划阶段，并决定是否执行整理</li>\n<li>如果需要整理，那么即执行重定位阶段和整理阶段；如果不需要整理，就执行清扫阶段</li>\n<li>垃圾回收器调用 <code class=\"language-text\">RestartEE</code> 重新恢复托管线程的执行</li>\n<li>用户线程继续执行</li>\n</ol>\n<h4 id=\"wks-gc开启并发-gc\" style=\"position:relative;\"><a href=\"#wks-gc%E5%BC%80%E5%90%AF%E5%B9%B6%E5%8F%91-gc\" aria-label=\"wks gc开启并发 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>WKS GC，开启并发 GC</h4>\n<p>这一节描述了后台 GC 是如何工作的。</p>\n<ol>\n<li>用户线程的分配额度不足，触发了垃圾回收</li>\n<li>垃圾回收器调用 <code class=\"language-text\">SuspendEE</code> 来暂停托管线程</li>\n<li>垃圾回收器决定是否需要启动后台 GC</li>\n<li>如果需要的话，那么一个后台 GC 线程将被唤醒。后台 GC 线程调用 <code class=\"language-text\">RestartEE</code> 来恢复托管线程</li>\n<li>托管线程继续分配内存，于此同时后台 GC 线程仍然在进行工作</li>\n<li>用户线程可能会由于分配额度不足，触发一次短暂 GC (即“前台 GC”)。短暂 GC 与上文“WKS GC，关闭并发 GC”的流程一致</li>\n<li>后台 GC 再次调用 <code class=\"language-text\">SuspendEE</code> 以便完成标记阶段，随后它会调用 <code class=\"language-text\">RestartEE</code> 重新恢复用户线程，此时清扫阶段与用户线程并发执行</li>\n<li>后台 GC 结束</li>\n</ol>\n<h4 id=\"svr-gc关闭并发-gc\" style=\"position:relative;\"><a href=\"#svr-gc%E5%85%B3%E9%97%AD%E5%B9%B6%E5%8F%91-gc\" aria-label=\"svr gc关闭并发 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SVR GC，关闭并发 GC</h4>\n<ol>\n<li>用户线程的分配额度不足，触发了垃圾回收</li>\n<li>Server GC 线程被唤醒，它们会调用 <code class=\"language-text\">SuspendEE</code> 来暂停托管线程</li>\n<li>Server GC 线程执行垃圾回收（与 WKS GC 关闭并发 GC 时的操作一致）</li>\n<li>Server GC 线程调用 <code class=\"language-text\">SuspendEE</code> 恢复托管线程</li>\n<li>用户线程继续执行</li>\n</ol>\n<h4 id=\"svr-gc开启并发-gc\" style=\"position:relative;\"><a href=\"#svr-gc%E5%BC%80%E5%90%AF%E5%B9%B6%E5%8F%91-gc\" aria-label=\"svr gc开启并发 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SVR GC，开启并发 GC</h4>\n<p>这一场景与 WKS GC 开启并发 GC 的行为大致一致，只是后台 GC 任务是在 Server GC 线程上完成的。</p>\n<h2 id=\"物理架构\" style=\"position:relative;\"><a href=\"#%E7%89%A9%E7%90%86%E6%9E%B6%E6%9E%84\" aria-label=\"物理架构 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>物理架构</h2>\n<p>这一节将有助于理解垃圾回收的代码流程。</p>\n<p>用户线程的分配量不足，它会通过 <code class=\"language-text\">try_allocate_more_space</code> 来申请新的分配量。当需要触发 GC 时，<code class=\"language-text\">try_allocate_more_space</code> 会调用 <code class=\"language-text\">GarbageCollectGeneration</code>。如果使用的是 WKS GC 并关闭了并发 GC，则 <code class=\"language-text\">GarbageCollectGeneration</code> 是在用户线程上执行的。代码流程为：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">GarbageCollectGeneration()\n {\n     SuspendEE();\n     garbage_collect();\n     RestartEE();\n }\n \n garbage_collect()\n {\n     generation_to_condemn();\n     gc1();\n }\n \n gc1()\n {\n     mark_phase();\n     plan_phase();\n }\n \n plan_phase()\n {\n     // actual plan phase work to decide to \n     // compact or not\n     if (compact)\n     {\n         relocate_phase();\n         compact_phase();\n     }\n     else\n         make_free_lists();\n }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果使用的是 WKS GC 并开启了并发 GC （这是默认情况），后台 GC 的代码流程为：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">GarbageCollectGeneration()\n {\n     SuspendEE();\n     garbage_collect();\n     RestartEE();\n }\n \n garbage_collect()\n {\n     generation_to_condemn();\n     // decide to do a background GC\n     // wake up the background GC thread to do the work\n     do_background_gc();\n }\n \n do_background_gc()\n {\n     init_background_gc();\n     start_c_gc ();\n \n     //wait until restarted by the BGC.\n     wait_to_proceed();\n }\n \n bgc_thread_function()\n {\n     while (1)\n     {\n         // wait on an event\n         // wake up\n         gc1();\n     }\n }\n \n gc1()\n {\n     background_mark_phase();\n     background_sweep();\n }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"其他资源\" style=\"position:relative;\"><a href=\"#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90\" aria-label=\"其他资源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>其他资源</h2>\n<ul>\n<li><a href=\"https://raw.githubusercontent.com/dotnet/coreclr/master/src/gc/gc.cpp\">.NET CLR GC Implementation</a></li>\n<li><a href=\"http://www.amazon.com/Garbage-Collection-Handbook-Management-Algorithms/dp/1420082795\">The Garbage Collection Handbook: The Art of Automatic Memory Management</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\">Garbage collection (Wikipedia)</a></li>\n<li><a href=\"https://prodotnetmemory.com/\">Pro .NET Memory Management</a></li>\n</ul>"},"childMdx":null}},{"node":{"id":"07deb23f-ffb2-5d7e-a543-804d35a3d718","relativePath":"botr/6-type-loader.md","childMarkdownRemark":{"fields":{"slug":"/botr/6-type-loader/"},"frontmatter":{"title":"六、CLR 类型加载器的设计"},"html":"<blockquote>\n<p>这是一篇译文。作者：Ladi Prosek - 2007<br>\n原文链接：<a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/type-loader.md\">https://github.com/dotnet/coreclr/blob/master/Documentation/botr/type-loader.md</a></p>\n</blockquote>\n<h2 id=\"引言\" style=\"position:relative;\"><a href=\"#%E5%BC%95%E8%A8%80\" aria-label=\"引言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>引言</h2>\n<p>在一个基于类的面向对象系统中，类型就是一种模板，它描述了每个独立的实例所包含的数据、以及它们能够提供的功能。如果没有定义一个对象的类型，我们就不可能创建出这个对象来<sup>1</sup>。如果我们说某两个对象的类型相同，那么它们一定是同一个类型的两个实例。事实上，这两个对象也定义了完全相同的成员，但这与类型判断完全无关。</p>\n<p>上面这段话其实也很好的描述了一个典型的 C++ 系统。不过 CLR 还有一个非常重要的基本功能，那就是它能够提供完整的运行时类型信息。为了“管理”托管代码、并提供一个类型安全的环境，运行时必须在任何时刻都能够知晓任何对象的类型。获取类型信息时，也不能引入复杂的计算，因为“类型比较”这一操作会非常频繁地发生（比如，任何类型转换都会涉及查询当前对象的类型信息，以便确定转换是安全的、可以操作的）。</p>\n<p>这种对性能上的需求，就把字典查询方法完全排除在外了。留给我们的，就只剩下下面这样的架构：</p>\n<p>图 1 抽象、宏观的对象设计</p>\n<p>在每个对象中，除了包含真正的实例数据，还有一个“type id”指针，指向一个代表了它的类型的结构。这样的概念与 C++ 中的虚表指针很像，然而不同的是，这种结构（我们先把它叫做“TYPE”，后面我们会更清楚地定义它）比虚表所包含的信息要多很多。比如，它还包含了类型的继承信息，以便我们能够回答“is-a”这样的问题。</p>\n<p><sup>1</sup> C# 3.0 中的“匿名类型”能够让你无需显式定义类型即可创建一个对象，只需要直接列出它的所有字段即可。不要被这个功能蒙蔽双眼，编译器其实背着你创建了一个类型。</p>\n<h3 id=\"相关阅读\" style=\"position:relative;\"><a href=\"#%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB\" aria-label=\"相关阅读 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>相关阅读</h3>\n<p>[1] Martin Abadi, Luca Cardelli, A Theory of Objects, ISBN\n978-0387947754</p>\n<p>[2] Andrew Kennedy (<a href=\"https://github.com/andrewjkennedy\">@andrewjkennedy</a>), Don Syme (<a href=\"https://github.com/dsyme\">@dsyme</a>), <a href=\"http://research.microsoft.com/apps/pubs/default.aspx?id=64031\">Design and Implementation of Generics\nfor the .NET Common Language\nRuntime</a></p>\n<p>[3] <a href=\"http://www.ecma-international.org/publications/standards/Ecma-335.htm\">ECMA Standard for the Common Language Infrastructure (CLI)</a></p>\n<h3 id=\"设计目标\" style=\"position:relative;\"><a href=\"#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87\" aria-label=\"设计目标 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>设计目标</h3>\n<p>有时我们也把类型加载器（type loader）叫做类加载器（class laoder），但严格来说这个叫法并不正确，因为类只能算是类型的一个子集，即引用类型。这个加载器也能加载值类型。类型加载器的终极目标是：当有人需要加载一个类型时，它能够构建出表示这个类型的数据结构。下面的这些性质是加载器所应该具备的：</p>\n<ul>\n<li>快速的类型查找（通过 Module 和 token 进行查找，或通过 Assembly 和类型名进行查找）。</li>\n<li>对内存布局进行优化，以便占用较小的内存工作集、实现较高的缓存命中率、以及提高 JIT 编译后代码的效率。</li>\n<li>类型安全——拒绝加载不正确的类型，并抛出 <code class=\"language-text\">TypeLoadException</code>.</li>\n<li>并发——能够扩展至多线程的场景。</li>\n</ul>\n<h2 id=\"类型加载器的架构\" style=\"position:relative;\"><a href=\"#%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%9E%B6%E6%9E%84\" aria-label=\"类型加载器的架构 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>类型加载器的架构</h2>\n<p>加载器的公开方法很少。尽管这几个方法的函数签名不尽相同，它们都有着相似的语义：接收一个元数据 <strong>token</strong> 或是类型名 <strong>name</strong> 字符串参数，它代表了某个类型或成员；接收另一个参数，代表了这个 token 所在的范围（某个 <strong>module</strong> 或是 <strong>assembly</strong>）；再接收一些额外信息，比如一些标志。它会以 <strong>handle</strong> 的型时返回加载好的实体。</p>\n<p>在 JIT 时，通常会调用多次类型加载器。考虑这样的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">object CreateClass()\n{\n    return new MyClass();\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 IL 层面，<code class=\"language-text\">MyClass</code> 以元数据 token 的方式被引用。<code class=\"language-text\">JIT_New</code> 帮助方法是真正做实例化工作的函数，为了生成对 <code class=\"language-text\">JIT_New</code> 调用指令， JIT 会要求类型加载器加载这个类型，并返回一个 handle。这个 handle 会被直接以立即数的形式嵌入到 JIT 编译后的代码中。由于类型和成员是在 JIT 阶段被解析和加载的（而不是在运行时），因此下面这样的代码很具有迷惑性：</p>\n<p>(译注：CLR 会先对函数进行 JIT 编译，而后才会执行它)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">object CreateClass()\n{\n    try {\n        return new MyClass();\n    } catch (TypeLoadException) {\n        return null;\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果 <code class=\"language-text\">MyClass</code> 类型加载失败（比如它所在的 Assembly 刚好在文件系统中被删掉了），它们这段代码仍然会抛出 <code class=\"language-text\">TypeLoadException</code>。<code class=\"language-text\">catch</code> 块没有捕获到这个异常的原因是是：这段代码根本没有执行！异常是在 JIT 时被抛出的，只能被调用 <code class=\"language-text\">CreateClass</code> 的函数（进而触发了 JIT 编译）所捕捉。不仅如此，考虑到存在内联（inline）这一特性，触发 JIT 编译的时机有时并不是那么明显，因此用户不应该依赖于这种难以琢磨的行为。</p>\n<h3 id=\"关键数据结构\" style=\"position:relative;\"><a href=\"#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" aria-label=\"关键数据结构 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>关键数据结构</h3>\n<p>在 CLR 中，最通用的类型表示方法是 <code class=\"language-text\">TypeHandle</code>。它是对 <code class=\"language-text\">MethodTable</code> 以及 <code class=\"language-text\">TypeDesc</code> 的抽象，即它要么封装了一个指向 <code class=\"language-text\">MethodTable</code> 的指针（它代表了“普通”的类型，比如 <code class=\"language-text\">System.Object</code> 或是 <code class=\"language-text\">List&lt;string></code>），要么封装了一个指向了 <code class=\"language-text\">TypeDesc</code> 的指针（代表了 byref、指针、函数指针、数组以及泛型类型）。它就是类型的标志，当且仅当两个 handle 相同时，它们所表示的类型也相同。为了节省空间， <code class=\"language-text\">TypeHandle</code> 通过指针的第二低位（the second lowest bit）来标记它到底是一个 <code class=\"language-text\">TypeDesc</code> 还是 <code class=\"language-text\">MethodTable</code> 。如果第二低位是 1 (即 (ptr | 2))，则代表它是一个 <code class=\"language-text\">TypeDesc</code><sup>2</sup>。<code class=\"language-text\">TypeDesc</code> 则是对下面几种类型的抽象：</p>\n<p>图 2 TypeDesc 体系</p>\n<p><code class=\"language-text\">TypeDesc</code></p>\n<p>抽象的类型描述符。具体的描述符类型由标志位决定。</p>\n<p><code class=\"language-text\">TypeVarTypeDesc</code></p>\n<p>代表了一个类型变量，例如在 <code class=\"language-text\">List&lt;T></code> 或是 <code class=\"language-text\">Array.Sort&lt;T></code> 中的那个 <code class=\"language-text\">T</code>（详见下文关于泛型的部分）。类型变量不会由多个类型或方法共享，因此每个变量都只有一个 owner。</p>\n<p><code class=\"language-text\">FnPtrTypeDesc</code></p>\n<p>代表了一个函数指针，它是由一组变长的类型 handle 列表组成的，这组 handle 表示了返回值和参数的类型。这个描述符并不常见，因为 C# 不支持函数指针。不过，托管 C++ 会使用这个描述符。</p>\n<p><code class=\"language-text\">ParamTypeDesc</code></p>\n<p>这个描述符代表了 byref 和指针类型。 在 C# 的方法参数中的使用 <code class=\"language-text\">ref</code> 和 <code class=\"language-text\">out</code> 关键字即可得到这种类型<sup>3</sup>；指针类型则代表了非托管的指向数据的指针，用于 unsafe C# 和托管 C++。</p>\n<p><code class=\"language-text\">ArrayTypeDesc</code></p>\n<p>代表了数组类型。它继承自 <code class=\"language-text\">ParamTypeDesc</code>，因为它同样只有一个类型参数（即元素的类型）。这与泛型实例化不同，泛型实例化所需要的参数是不定的。</p>\n<p><code class=\"language-text\">MethodTable</code></p>\n<p>目前，运行时中最核心的类型数据结构就是它了。它代表着所有没有落入到上述类别中的类型（包括基本类型、开放（open）或闭合（closed）泛型类型）。它包含了所有需要快速查找的信息，例如它的父类型、实现的接口，以及虚表。</p>\n<p><code class=\"language-text\">EEClass</code></p>\n<p><code class=\"language-text\">MethodTable</code> 数据分为两类，“热（hot）” 结构和 “冷（cold）” 结构，这将有利于降低内存占用以及更有利于缓存的使用。<code class=\"language-text\">MethodTable</code> 本身只用来存储常用（热）数据，即那些为了执行程序所必须的数据。<code class=\"language-text\">EEClass</code> 保存不常用的（冷）数据，这些数据通常只在类型加载、JIT 编译或是反射时才需要。每一个 <code class=\"language-text\">MethodTable</code> 都指向一个 <code class=\"language-text\">EEClass</code>。</p>\n<p>此外，<code class=\"language-text\">EEClass</code> 在泛型类型之间是共享的。多个泛型 <code class=\"language-text\">MethodTable</code> 可能会指向同一个 <code class=\"language-text\">EEClass</code>。这就对能够存放在 <code class=\"language-text\">EEClass</code> 中的数据提出了额外的限制条件。</p>\n<p><code class=\"language-text\">MethodDesc</code></p>\n<p>顾名思义，这个结构描述了一个方法。其实这个结构通常都以它的一些子类型出现，不过大多数子类型都已经超出了这篇文章的范围。其中有一个子类型值得一提：<code class=\"language-text\">InstantiatedMethodDesc</code>，它在泛型类型中扮演了一个重要的角色。更多信息请参考\n<a href=\"/botr/method-descriptor.md/\"><strong>Method Descriptor Design</strong></a>。</p>\n<p><code class=\"language-text\">FieldDesc</code></p>\n<p>与 <code class=\"language-text\">MethodDesc</code> 类似，这个结构描述的是一个字段。除了某些特定的 COM 交互场景，执行引擎根本不在乎属性（property）和事件（events），因为它们最终还是会指向各种方法和字段。只有编译器、以及反射机制能够生成或理解属性和事件，这只是一种语法糖。</p>\n<p><sup>2</sup>这在调试时非常有用。如果 <code class=\"language-text\">TypeHandle</code> 的值以2、6、A、或 E 结尾，那么它就不是一个 <code class=\"language-text\">MethodTable</code>。如果想要访问到 <code class=\"language-text\">TypeDesc</code>，这个多余的位需要清零。</p>\n<p><sup>3</sup>需要注意的是，<code class=\"language-text\">ref</code> 和 <code class=\"language-text\">out</code> 之间只在参数属性上有所不同。对于类型系统来说，它们其实是相同的类型。</p>\n<h3 id=\"加载级别load-levels\" style=\"position:relative;\"><a href=\"#%E5%8A%A0%E8%BD%BD%E7%BA%A7%E5%88%ABload-levels\" aria-label=\"加载级别load levels permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>加载级别（Load Levels）</h3>\n<p>我们可以使用诸如 typedef/typeref/typespec 之类的 <strong>token</strong>、并指定一个 <strong>Module</strong> 来加载类型。当类型加载器加载类型时，它并不会一次性做完所有的工作，而是分阶段完成的。这样做的原因是，有一些类型可能会依赖其他类型，因此如果要完成类型的加载，则必须先加载那些被依赖的类型，二者可能会导致无限递归和死锁。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class A&lt;T> : C&lt;B&lt;T>>\n{ }\n\nclass B&lt;T> : C&lt;A&lt;T>>\n{ }\n\nclass C&lt;T>\n{ }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>它们都是合法的类型，很明显 <code class=\"language-text\">A</code> 依赖于 <code class=\"language-text\">B</code>，同时 <code class=\"language-text\">B</code> 也依赖于 <code class=\"language-text\">A</code>。</p>\n<p>加载类型时，加载器会先创建一些结构用来表示被加载的类型，此时并不需要加载其他被依赖的类型。这一步完成后，这些结构就可以被其它地方所引用，例如把指向它的指针塞进其他结构中。然后假踩起就会不断地一点一点把这些结构填满，一直到真正加载完这些类型。在上面的例子中，<code class=\"language-text\">A</code> 和 <code class=\"language-text\">B</code> 的基类会首先近似为一种不需要依赖其他类型的类型，然后才会被真正的类型所替代。</p>\n<p>所谓的加载级别，就是为了定义这种未完全加载的状态。从 <code class=\"language-text\">CLASS_LOAD_BEGIN</code> 开始，到 <code class=\"language-text\">CLASS_LOADED</code> 结束，中间穿插了很多中间级别。在 <a href=\"https://github.com/dotnet/coreclr/blob/master/src/vm/classloadlevel.h\">classloadlevel.h</a> 中，有很详细的注释对各个加载级别进行了说明。例如，类型可以以 NGEN 镜像的形式存储，但并不是简单地把它们映射到内存就能使用，而是需要“恢复”（restore）。加载等级中有一级叫做 <code class=\"language-text\">CLASS_LOAD_UNRESTORED</code>，它就描述了这种需要“恢复”的状态。</p>\n<p>更多对于加载等级的详细解释，请参考 <a href=\"http://research.microsoft.com/apps/pubs/default.aspx?id=64031\">Design and Implementation of Generics\nfor the .NET Common Language\nRuntime</a>。</p>\n<h3 id=\"generics\" style=\"position:relative;\"><a href=\"#generics\" aria-label=\"generics permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generics</h3>\n<p>在没有泛型的世界里，一切都很友好、所有人都很开心——因为每个普通的类型（即不是由 <code class=\"language-text\">TypeDesc</code> 所表示的类型）都只有一个 <code class=\"language-text\">MethodTable</code>，其中包含了指向了它所关联的 <code class=\"language-text\">EEClass</code> 的指针，而 <code class=\"language-text\">EEClass</code> 又指回了这个 <code class=\"language-text\">MethodTable</code>。为了节省空间，代表了方法的 <code class=\"language-text\">MethodDesc</code> 几个组成一组，每组之间以链表的形式相连<sup>4</sup>：</p>\n<p>图 3 没有泛型方法的非泛型类型</p>\n<p><sup>4</sup>在执行托管代码时，并不是需要去查询这些组才能进行方法调用。方法调用是一种非常常见的操作，通常只需要 <code class=\"language-text\">MethodTable</code> 中的信息就能完成。</p>\n<h4 id=\"术语\" style=\"position:relative;\"><a href=\"#%E6%9C%AF%E8%AF%AD\" aria-label=\"术语 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>术语</h4>\n<p><strong>泛型形式参数（Generic Parameter）</strong></p>\n<p>是指一个占位符，能够被其他类型替代，例如声明 <code class=\"language-text\">List&lt;T></code> 中的 <code class=\"language-text\">T</code>。有时也称作形式类型参数（formal type parameter）。泛型形参具有名字，以及可选的泛型约束。</p>\n<p><strong>泛型实际参数(Generic Argument)</strong></p>\n<p>是指用来替代形参的那个类型，例如 <code class=\"language-text\">List&lt;int></code> 中的 <code class=\"language-text\">int</code>。需要注意的是，泛型形参也可以被用作一个实参。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">List&lt;T> GetList&lt;T>()\n{\n    return new List&lt;T>();\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个方法有一个泛型形参 <code class=\"language-text\">T</code>，它被用作了泛型列表的泛型实参。</p>\n<p><strong>泛型约束</strong></p>\n<p>是可选的，它是指当泛型实参替代反省形参时所需满足的要求。不满足要求的类型不能替换反省实参，这是由类型加载器所强制要求的。泛型约束分为三类：</p>\n<ol>\n<li>特殊约束</li>\n</ol>\n<ul>\n<li>\n<p>引用类型约束——泛型实参必须是引用类型（与之相对的是值类型）。C# 使用 <code class=\"language-text\">class</code> 关键字来表示这种约束。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">public class A&lt;T> where T : class</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>\n<p>值类型约束——反省实参必须是除了 <code class=\"language-text\">System.Nulable&lt;T></code> 之外的值类型。 C# 使用 <code class=\"language-text\">struct</code> 关键字来表示。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">public class A&lt;T> where T : struct</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>\n<p>默认构造函数约束——泛型实参必须要具有一个公开的无参构造函数。C# 使用 <code class=\"language-text\">new()</code> 来表示这种约束。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">public class A&lt;T> where T : new()</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>基类型约束——泛型实参必须继承自（或者就是）给定的非接口类型。很显然，这种约束要么没有，要么只能有一个引用类型作为约束。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">public class A&lt;T> where T : EventArgs</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>\n<p>接口实现约束——泛型实参必须实现（或者就是）给定的接口类型。多个接口可以同时作为约束：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">public class A&lt;T> where T : ICloneable, IComparable&lt;T></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n</ol>\n<p>上面这些约束之间的关系是“与”（AND），即一个泛型形参可以被约束为需要继承自一个给定的类型、实现几个接口、同时还需要有默认构造函数。类型声明中所有的泛型形参都可以用来表达约束，这可能会引入参数之间的互相依赖：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">public class A&lt;S, T, U> \n\twhere S : T \n\twhere T : IList&lt;U> {\n    void f&lt;V>(V v) where V : S {}\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>实例（Instantiation）</strong></p>\n<p>是用来替换泛型类型或泛型方法中泛型形参的一组泛型实参。每个加载了的泛型类型和方法都有它自己的实例。</p>\n<p><strong>典型实例（Typical Instantiation）</strong></p>\n<p>是指按照泛型形参声明的顺序，仅包含泛型类型或方法自己的类型形参的一个实例。对于每一个泛型类型和方法，仅存在一个典型实例。通常来说，当我们提到开放泛型类型（Open generic type）时，就是指它的典型实例。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">public class A&lt;S, T, U> {}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>C# 会把 <code class=\"language-text\">typeof(A&lt;,,>)</code> 编译为一个 IdToken A'3，运行时就会加载使用 <code class=\"language-text\">S</code>、<code class=\"language-text\">T</code>、<code class=\"language-text\">U</code> 实例化的 <code class=\"language-text\">A`3</code>。</p>\n<p><strong>规范实例（Canonical Instantiation）</strong></p>\n<p>是指所有的泛型实参均为 <code class=\"language-text\">System.__Canon</code> 的实例。<code class=\"language-text\">System.__Canon</code> 是定义在 mscorlib 中的一个内部类型，它就只充当一种约定，与其他的泛型实参都不同。类型和方法的规范实例用来代表所有的其他实例，并且携带有会在所有实例之间共享的信息。显然，<code class=\"language-text\">System.__Canon</code> 无法满足泛型形参上可能携带的任何约束，因此对于 <code class=\"language-text\">System.__Canon</code> 约束检查是个特例，加载器会将不满足的约束忽略。</p>\n<h3 id=\"共享\" style=\"position:relative;\"><a href=\"#%E5%85%B1%E4%BA%AB\" aria-label=\"共享 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>共享</h3>\n<p>随着泛型的加入，运行时需要加载的类型变得更多了。虽然泛型类型的不同实例（例如 <code class=\"language-text\">List&lt;string></code> 和 <code class=\"language-text\">List&lt;object></code>）是不同的类型，也各自有它们自己的 <code class=\"language-text\">MethodTable</code>，但还是有有一些信息是重复的，可以共享。这种共享会给内存占用和性能都带来积极影响。</p>\n<p>图 4 不包含泛型方法的泛型类型——共享 EEClass</p>\n<p>目前所有包含引用类型的实例都会共享同一个 <code class=\"language-text\">EEClass</code> 以及 <code class=\"language-text\">MethodDesc</code>。这种方式可行的原因在于，所有的引用所占用的内存大小都一样，例如4个字节或是8个字节，因此这些类型的布局都相同。上图示意了 <code class=\"language-text\">List&lt;object></code> 和 <code class=\"language-text\">List&lt;string></code> 的情形。那个规范的 <code class=\"language-text\">MethodTable</code> 会在第一个引用类型实例加载时自动创建，它里面包含了那些常用的、不局限于某个特定实例的数据，例如非虚的方法槽以及 <code class=\"language-text\">RemotableMethodInfo</code>。只包含值类型的实例不会共享信息，每一个实例化的类型都会有它自己独立的 <code class=\"language-text\">EEClass</code>。</p>\n<p>已加载的泛型类型的 <code class=\"language-text\">MethodTable</code> 会被缓存在一个哈希表中，这个哈希表由加载它们的模块所持有。在一个新的实例构造之前，加载器会首先查询这个哈希表，这样就不会出现有同一个类型具有多个 <code class=\"language-text\">MethodTable</code> 实例的情况了。</p>\n<p>更多关于泛型共享的细节，请参考 <a href=\"http://research.microsoft.com/apps/pubs/default.aspx?id=64031\">Design and Implementation of Generics for the .NET Common Language Runtime</a>。</p>"},"childMdx":null}},{"node":{"id":"6a830d55-b977-5093-a031-c8282ef9ca9c","relativePath":"botr/short-intro.md","childMarkdownRemark":{"fields":{"slug":"/botr/short-intro/"},"frontmatter":{"title":""},"html":"<p><a href=\"https://github.com/dotnet/coreclr/tree/master/Documentation/botr\"><em>Book of the Runtime</em></a> 是一组由 .Net 团队撰写的系列文章，讨论了 .Net 运行时的一些内部机制，能够帮助大家更深入地理解 .Net 运行时。这些文章诞生于 2007 年左右，当时用作微软 .Net 团队的入职学习资料。</p>"},"childMdx":null}},{"node":{"id":"f58817c2-798e-51e1-95f9-5743d8e5b436","relativePath":"the-error-model/0-introduction.md","childMarkdownRemark":{"fields":{"slug":"/the-error-model/0-introduction/"},"frontmatter":{"title":"〇、错误模型简介"},"html":"<blockquote>\n<p>译注：</p>\n<p>原作者 Joe Duffy 曾在微软参与开发一款操作系统 Midori，这是一款研究型/孵化型项目。这款操作系统主要由一种 C# 的变种语言（有人称作 M# 语言）编写。</p>\n<p>下文中所有的“我”、“我们”均指代原作者 Joe Duffy 或其所在团队。作者总结了目前主流编程语言中常见的错误模型的优缺点，同时分别给出了自己的针对不可恢复错误（Unrecoverable Error）和可恢复错误（Recoverable Error）的处理方案。由于本文有一些惯用语和专业词语，受限于我的水平，可能出现翻译错误、或措辞与主流方案不同等问题，欢迎指出以便修正。本文较长，请做好长时间阅读的准备。</p>\n<p>原文链接：<a href=\"http://joeduffyblog.com/2016/02/07/the-error-model/\">http://joeduffyblog.com/2016/02/07/the-error-model/</a></p>\n</blockquote>\n<p>Midori 使用了一种基于 C# 的、支持 AOT 编译、类型安全的语言。除了我们的微内核，整个系统都是使用这种语言编写的，包括驱动程序、域内核（Domain Kernel），以及全部的用户代码。我在这段时间里收获了很多，现在是时候总结一下了。整个语言涵盖的东西太多了，我会分成几篇文章来阐述，就先从错误模型开始。错误（Errors）的传递与处理在任何编程语言中都是非常基础的部分，而对于用来编写高可靠操作系统的语言来说更是如此。就像 Midori 项目的其他部分一样，任何修改一部分都应该从全局的角度来考量，并进行不断地迭代。我经常从原来的同事那里听到说，错误模型是他们在 Midori 上开发程序时最怀念的部分。我也很怀念这部分。那么废话少说，我们这就开始。</p>\n<h2 id=\"错误模型简介\" style=\"position:relative;\"><a href=\"#%E9%94%99%E8%AF%AF%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B\" aria-label=\"错误模型简介 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>错误模型简介</h2>\n<p>错误模型需要回答的最基本的问题是：“错误”应该如何传达给程序员和用户？这问题似乎很简单。</p>\n<p>要回答这个问题，最大的阻碍之一是：如何定义什么是“错误”。很多语言把 Bug 和可恢复错误归为一类，用同样的机制来处理，比如把空指针引用错误、数组访问越界错误与网络连接错误、语法分析错误混为一谈。这种一致性初看起来很美好，但它有着深层次的问题——这种一致性会造成很大误解，并且通常会导致程序员写出不可靠的代码。</p>\n<p>总的来说，我们的解决方法是同时提供两套错误模型。一方面，对于程序的 Bug，我们提供了快速失败（Fail-Fast）模型，在 Midori 中我们称其为放弃（Abandonment）；另一方面，对于可恢复的错误，我们也提供了静态受检查异常（Statically Checked Exception）。这两种错误模型从编程模式到背后的机制都截然不同。放弃会无条件地立即终止整个进程，不会再运行任何用户代码（需要说明的是：一个典型的 Midori 程序会由很多个小的、轻量级的进程组成）；异常则允许恢复用户代码的执行，在这个过程中类型系统会起到重要的检查和验证的作用。</p>\n<p>我们的旅程漫长而曲折。为了讲好这段故事，这篇文章分为以下6个主要部分：</p>\n<ul>\n<li>野心和经验</li>\n<li>Bugs 不是可恢复错误！</li>\n<li>可靠性、容错性和隔离性</li>\n<li>Bugs：放弃（Abandonment）、断言（Assertions）和合约（Contracts）</li>\n<li>可恢复错误：类型导向的异常回顾与总结</li>\n</ul>\n<p>现在看来，有些结论似乎很明显，尤其是在更现代的系统语言（比如 Go 和 Rust）出现之后。但是一些结论还是让我们很惊讶。我会尽量省略废话，但也会提供足够的背景故事。我们走过很多弯路，但我觉得这些弯路甚至要比最终的结论更有趣。</p>"},"childMdx":null}},{"node":{"id":"57937499-32f6-54ca-90f6-15b6bfaede77","relativePath":"the-error-model/1-ambitions-and-learnings.md","childMarkdownRemark":{"fields":{"slug":"/the-error-model/1-ambitions-and-learnings/"},"frontmatter":{"title":"一、野心和经验"},"html":"<blockquote>\n<p>这是一篇译文。原文链接：<a href=\"http://joeduffyblog.com/2016/02/07/the-error-model/\">http://joeduffyblog.com/2016/02/07/the-error-model/</a></p>\n</blockquote>\n<p>让我们首先来看看现有的系统，总结一下我们需要哪些东西，并从中学习一些架构方面的经验。</p>\n<h2 id=\"准则\" style=\"position:relative;\"><a href=\"#%E5%87%86%E5%88%99\" aria-label=\"准则 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>准则</h2>\n<p>首先，我们需要定义什么是一个好的错误模型：</p>\n<ul>\n<li>\n<p>易用性：在开发人员面对程序错误的时候，他们必须能够非常方便、甚至不加思考地做出“正确的事”。一个朋友（也是同事）说这就叫做“好坑（The Pit of Success）”。错误模型不能为编码工作增添大量的额外负担。正常情况下，开发人员应该对它非常熟悉。</p>\n</li>\n<li>\n<p>可靠性：错误模型是整个系统可靠性的基础。毕竟我们正在编写一个操作系统，可靠性是最重要的。有人可能会觉得我们太过于重视这一点了。我们提倡“构建正确”（Correct by Construction），很多编程模型的开发都基于这个理念。</p>\n</li>\n<li>\n<p>性能：在大多数情况下，我们都希望代码能够足够快。也就是说，在没有发生错误的时候，我们需要尽可能地减少性能损失。而对于发生错误的时候，任何额外的性能开销必须是“按需付费”。与很多愿意在发生错误时过度损失性能的现代系统不同，我们有一些对性能非常敏感的组件，当发生错误时它们也需要足够快才行。</p>\n</li>\n<li>\n<p>并发：我们的整个系统都是高并发、分布式的。对于其他的错误模型来说，这通常是事后才考虑的事情，但我们需要提前正视这个问题。</p>\n</li>\n<li>\n<p>诊断：不论是交互式调试还是事后调试，都需要简单而高效。</p>\n</li>\n<li>\n<p>协调：从根本上讲，错误模型是一种编程语言的功能，是开发人员表达代码逻辑的重要部分。因此，错误模型必须与系统中的其他功能协调一致。不同组件之间的集成必须是自然的、可靠的，结果是可预测的。</p>\n</li>\n</ul>\n<p>这些要求也许有些严格，但我认为最终我们在所有的方面都取得了成功。</p>\n<h2 id=\"经验\" style=\"position:relative;\"><a href=\"#%E7%BB%8F%E9%AA%8C\" aria-label=\"经验 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>经验</h2>\n<p>现有的错误模型并没有满足我们上面提到的要求，至少没有全部满足。通常某个错误模型可以在一个方面做的很好，但在另一个方面却很差。比如，错误码可以有很高可靠性，但很多程序员发现错误码在使用时很可能会出错。具体来说，它很容易导致程序员做出错误的事，比如忘记检查错误码。这明显违背了“好坑”原则。</p>\n<p>考虑到我们寻求的是最高等级的可靠性，大多数模型都不能满足我们的需求也不足为奇了。</p>\n<p>相比于可靠性，如果易用性是更优先的目标（例如你在使用一门脚本语言），那么结论可能会完全不同。Java 和 C## 之类的语言的纠结之处在于，它们的使用场景可能很复杂——有时候用于系统编程，有时候用于应用编程。总的来说，它们的错误模型很不满足我们的需求。</p>\n<p>最后需要说明的是，我们的故事开始于十几年前，那时还没有 Go、Rust、Swift 等语言供我们参考。这三门语言在错误模型方面取得了很大的进步。</p>\n<h3 id=\"错误码\" style=\"position:relative;\"><a href=\"#%E9%94%99%E8%AF%AF%E7%A0%81\" aria-label=\"错误码 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>错误码</h3>\n<p>错误码大概可以说是最简单的错误模型了，它背后的原理非常基础，甚至不需要语言或运行时的支持。函数返回一个值，通常来说是一个整数，来表明成功或失败。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 执行一些语句</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这就是很一种典型的模式，返回0表示成功，非零值表示失败。调用时必须检查返回值：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> err <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 出错了！赶紧搞定</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>大多数系统支持使用常量来表示一组错误码，而不是直接使用具体的数字。也可能会有一些函数用于获取最近一次错误的详细信息（比如 C 语言中的errno，以及 Win32 中的 GetLastError）。返回一个错误码确实不是什么特殊的事——就是返回一个值。</p>\n<p>C 语言一直在使用错误码。因此，大多数基于 C 语言的生态系统也用错误码。很多底层系统的代码也使用了返回错误码的方法，Linux 如此，不计其数的关键任务系统、实时系统也如此。公平地说，错误码模型有着深远的历史和广泛的影响。</p>\n<p>在 Windows 上，<code class=\"language-text\">HRESULT</code>也是一样，它就只是一个整数“句柄”，还附带了一堆常量和宏，例如<code class=\"language-text\">S_OK</code>、<code class=\"language-text\">E_FAULT</code>、<code class=\"language-text\">SUCCEEDED()</code>，定义在<code class=\"language-text\">winerror.h</code>里面。这些常量和宏用来创建或检查返回值。Windows 最核心的部分都使用了返回错误码的方式。内核里面不会使用异常，至少不会刻意去使用。</p>\n<p>在一些需要手动管理内存的环境下，发生错误时释放内存尤其困难。考虑到这种情况，返回错误码的方式相对可以接受。C++ 使用 RAII 来自动解决这个问题，但是除非你非常认同整个 C++ 的编程模型（很多系统程序员并不），在 C 语言中没什么好的方法来添加上 RAII 的功能。</p>\n<p>Go 语言选择了使用错误码。虽然 Go 的方式与 C 很像，但它提供了更加现代化的语法和库的支持。</p>\n<p>很多函数式编程语言也使用返回码——它们可能被掩盖在 Monad、<code class=\"language-text\">Option&lt;T></code>、<code class=\"language-text\">Maybe&lt;T></code>、或是 <code class=\"language-text\">Error&lt;T></code> 里面。它们与数据流、模式匹配相结合，使用起来更加自然。这种方法解决了错误码的很多弊端（我们会在下文提到），尤其是与 C 相对比更是如此。Rust 大范围地采用了这个模型，同时也提供了令很多系统程序员非常欣赏的新功能。</p>\n<p>尽管错误码具有非常简洁的优势，它也会带来一些包袱，比如：</p>\n<ul>\n<li>性能可能会受到影响。易</li>\n<li>用性可能会很差。</li>\n<li>最重要的一点：你可能会忘记检查错误码。</li>\n</ul>\n<p>我们会结合上面提到的那些语言逐条讨论。</p>\n<h4 id=\"性能\" style=\"position:relative;\"><a href=\"#%E6%80%A7%E8%83%BD\" aria-label=\"性能 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>性能</h4>\n<p>错误码并不满足“对于大部分场景提供性能零负担，对于小部分场景按需‘付费’”的标准：</p>\n<ol>\n<li>\n<p>对调用约定的影响。现在，对于非 void 返回值类型的函数来说，你需要返回两个值：一个是真正的返回值，一个是可能发生的错误。这就消耗了更多的寄存器和/或栈空间，让函数调用变得不高效。当然，对于可以内联的函数来说，内联可以帮忙解决一些问题。</p>\n</li>\n<li>\n<p>当被调用方可能产生错误的时候，调用方需要有很多的分支来进行处理。我把这种开销叫做“花生酱”，因为分支检查随意分布在代码中，很难直接测量它的影响。在 Midori 中，我们曾做过实验，并且确认了这些分支确实会带来性能损失。分支太多还会带来另一方面的影响——编译器中的优化器可能会被这么多的分支搞蒙。</p>\n</li>\n</ol>\n<p>也许对很多人来说这个结论有点让人惊讶，毕竟每个人都一定听说过“异常很慢”。事实证明，未必如此。而且，在使用正确的情况下，异常会让错误处理代码和数据与热路径（Hot Path）分开，这就增加了 L 缓存和 TLB 的性能。而在上述错误码的模型中，L 缓存和 TLB 的性能会明显受到影响。</p>\n<p>你可能会觉得我在吹毛求疵，对这种模型太过苛刻，毕竟很多高性能系统都在使用错误码模型。然而，下面我们将看到错误码模型的更严重的问题。</p>\n<h4 id=\"忘记检查错误码\" style=\"position:relative;\"><a href=\"#%E5%BF%98%E8%AE%B0%E6%A3%80%E6%9F%A5%E9%94%99%E8%AF%AF%E7%A0%81\" aria-label=\"忘记检查错误码 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>忘记检查错误码</h4>\n<p>开发人员非常容易忘记检查函数返回的错误码。比如，有这样一个函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>在调用时，如果我们默默地忽略返回值并且继续执行呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 继续执行 —— 但是 foo 可能已经失败了！</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>在这个时候，你已经掩盖了程序中的一个潜在关键错误。这是错误码最烦人、也是后果最严重的问题。后面我会提到，一些函数式语言使用了“Option”类型来解决这一点不足。但是对于基于 C 的语言，甚至对于具备现代语法的 Go 来说，这是一个确实存在的问题。</p>\n<p>我不是在纸上谈兵。我遇到过无数的 Bug，都是由于忽略了返回值引起的，我相信你也遇到过。事实上在使用错误码模型时，我的团队同事遇到了一些很有趣的 Bug。比如，当时我们在往 Midori 上移植微软的语音服务（Microsoft’s Speech Server），结果发现80%的繁体中文请求会失败——不是那种立刻就抛出来的错误，而是表现为客户端收到了一些垃圾数据。一开始我们以为是我们自己的问题，但最终我们发现是原始代码中忽略了<code class=\"language-text\">HRESULT</code>返回值。当移植到 Midori 上时，这个 Bug 就突然出现了。这一段经历佐证了我们关于错误码的观点。</p>\n<p>对于 Go 语言，我有点小惊讶。Go 语言认为未使用的<code class=\"language-text\">import</code>是一种错误，但居然在返回码这种关键得多的地方不做要求。太可惜了！</p>\n<p>当然，你可以使用静态分析器，或者在编译时给出一个“未使用的返回值”的警告（很多商业 C++ 编译器都有支持）。但是如果它不是一门语言的核心功能、作为一项强制要求，由于代码分析的噪声存在，这些方法都不会起到根本性的作用。</p>\n<p>由于这些原因，在我们的语言里，没有使用的返回值是一种编译错误。你需要显示地忽略他们。一开始我们我们使用了 API 来搞定这个问题，但是最终我们还是设计了专门的语法——等同于<code class=\"language-text\">>/dev/null</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">ignore foo();</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>虽然我们不使用错误码模型，但无法隐式忽略一个函数的返回值对于提高系统的整体可靠性来说非常重要。你有多少次调试之后才发现，根本问题只是在于忘记使用了返回值？当然，让程序员必须使用ignore并没有真正解决问题，他们还是可能会做错事。但是这至少需要明确地说出来，并且便于代码审查。</p>\n<h4 id=\"编程模型的易用性\" style=\"position:relative;\"><a href=\"#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%98%93%E7%94%A8%E6%80%A7\" aria-label=\"编程模型的易用性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>编程模型的易用性</h4>\n<p>在基于 C 的、使用错误码的语言中，你会发现在调用函数之后需要很多<code class=\"language-text\">if</code>检查语句。C 语言程序中，由于申请内存失败也是采用了返回错误码来表示，因此很多函数都可能会返回错误信息，这让写那些if变得更没意思。而如果需要返回多个值，也会让代码变得更臃肿。</p>\n<p>提示：这是我个人主观的想法。其实有很多方法，可以让你优雅地使用错误码。不过你所能用的只是一些非常简单的结构——整数，<code class=\"language-text\">return</code>，<code class=\"language-text\">if</code>分支，它们也会在其他地方使用。以我的拙见，错误处理的重要性足以让它在编程语言特性当中占有一席之地，编程与语言应当辅助你完成这些工作。</p>\n<p>Go 提供了一种语法捷径，能够是标准的错误码检查 <em>稍微地</em> 优雅一些：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token keyword\">if</span> err <span class=\"token operator\">:=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 错误处理</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>我们在一行代码中实现了调用foo、并检查错误是否非<code class=\"language-text\">nil</code>。非常简洁。</p>\n<p>然而，错误码在易用性方面并不止存在上述这些问题。</p>\n<p>很常见的是，一个函数通常会共享很多错误恢复和补救的逻辑。很多 C 语言程序员使用标签和goto来组织这些代码。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> error<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...</span>\n\nerror <span class=\"token operator\">=</span> <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">goto</span> Error<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ...</span>\n\nerror <span class=\"token operator\">=</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">goto</span> Error<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ...</span>\n\n<span class=\"token comment\">// 函数正常退出</span>\n<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...</span>\nError<span class=\"token operator\">:</span>\n<span class=\"token comment\">// 根据`error`值进行一些额外处理</span>\n<span class=\"token keyword\">return</span> error<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>不用说，这样的代码天下间只有母亲才可能会喜欢。</p>\n<p>在一些语言中，例如 D、C#、Java，<code class=\"language-text\">finally</code>代码块可以用来直接实现这种“在作用域结束之前执行”的模式。类似的还有微软的 C++ 私有扩展 <code class=\"language-text\">__finally</code>，即便你不认同 RAII 和异常，也可以单独使用这个扩展。D 语言提供了<code class=\"language-text\">scope</code>，Go 语言提供了<code class=\"language-text\">defer</code>。所有的这些都是在帮助从根本上去除<code class=\"language-text\">goto Error</code>模式。</p>\n<p>接下来考虑一下，如果我的函数想要同时返回一个值以及可能发生的错误，怎么办？我们已经占用了返回值，所以下面是两种显而易见的方案：</p>\n<ol>\n<li>\n<p>我们可以使用返回值返回两个值当中的一个（通常是错误码），而另一个（通常是真正的返回值）则通过其他方式——例如指针参数——进行返回。这在 C 语言中非常常见。</p>\n</li>\n<li>\n<p>我们可以返回一个数据结构，这种结构既可能携带真正的返回值，也可能携带错误码。但是像是在 C 语言、甚至是 Go 语言中，由于没有参数多态，返回值会丢失类型信息，因此这种做法不常见。C++ 有模板，因此理论来说它是可以做到的，但由于 C++ 支持异常，很少有围绕返回错误码构建的生态。</p>\n</li>\n</ol>\n<p>结合上文中提到的性能问题，想一想这两种方法对你的程序编译后产生的汇编代码有什么影响。</p>\n<h4 id=\"从旁路返回的返回值\" style=\"position:relative;\"><a href=\"#%E4%BB%8E%E6%97%81%E8%B7%AF%E8%BF%94%E5%9B%9E%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC\" aria-label=\"从旁路返回的返回值 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>从旁路返回的返回值</h4>\n<p>第一种方案，用 C 语言来实现的话，就像这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> out<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 执行一些操作</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">*</span>out <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>返回值只能从旁路返回，让调用的代码显得很笨：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 出错了！</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 使用value...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>除此之外，这种模式还会对编译器的<a href=\"https://en.wikipedia.org/wiki/Definite_assignment_analysis\">确定性赋值分析</a>造成干扰，例如可能会影响编译器无法给出“使用未初始化的变量”之类的警告。</p>\n<p>针对这个问题，Go 同样提供了很漂亮的语法，得益于多返回值：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> failed <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> errors<span class=\"token punctuation\">.</span><span class=\"token function\">New</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Bad things happened\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>调用方也因此变得简洁很多。与上面提到的单行if检查将结合的话——虽然有点奇怪，因为初看下面的代码可能会以为value不在作用域中，但它确实在——错误检查也变得更优雅：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token keyword\">if</span> value<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Error!  Deal with it.</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Use value ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>值得注意的是，这同样有助于提醒你检查错误码。当然这也没有从根本上解决这个问题，因为函数可能会只返回错误码，这时就和 C 语言一样，很容易忘记检查。</p>\n<p>就像上面提到的一样，一些人可能会在易用性这一点上反对我。我猜尤其是 Go 语言的设计师们。其实，Go 语言使用错误码这一点非常吸引我，它就像是对当今世界过于复杂的语言的一种反叛。我们已经丢失了 C 语言的优雅性——通常看到一行 C 语言代码，我们就能够猜出它被翻译成机器码后是什么样子的。我不会反对这些观点。事实上，相比于不受检查的异常和 Java 典型的受检查异常，我更喜欢 Go 语言的模型。最近我也写了很多 Go 代码，在我写下这篇文章的时候，想起 Go 的简洁性，我甚至在反思：Midori 是不是在 <code class=\"language-text\">try</code> 和 <code class=\"language-text\">require</code> 的道路上走的太远了？我不知道。Go 的错误模型似乎是这门语言中最具争议的一部分，也许很大程度上是因为你不能像在其他语言里那样草率地对待错误。但是，Midori 也不允许程序员草率地对待错误，可是程序员们确实很喜欢在 Midori 上编程。所以我很难做出比较。我只能确信这两种方式都能够写出可靠的代码。</p>\n<h4 id=\"使用数据结构包裹返回值\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8C%85%E8%A3%B9%E8%BF%94%E5%9B%9E%E5%80%BC\" aria-label=\"使用数据结构包裹返回值 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用数据结构包裹返回值</h4>\n<p>使用数据结构返回函数值函数式编程语言通常这样来解决易用性的问题：一个数据结构，既可能包含了函数返回值，也可能包含了错误码。在调用者使用返回值的时候，你必须把这个数据结构拆开，检查是否有错误，才能继续使用函数的返回值。这对多亏了数据流的编程风格。这样就很容易地避免了忘记检查错误这类严重的问题易用</p>\n<p>举一个现代语言的例子，你可以看看 Scala 的 <code class=\"language-text\">Option</code> 类型。不过很遗憾的是，一些语言（例如 ML 家族，以及 Scala —— 这得归咎于 JVM）把这种优雅的模型跟不受检查的异常混合在了一起。这破坏了使用数据结构返回数据的优雅性。</p>\n<p>Haskell 甚至更酷，它使用了错误值和局部控制流来给人一种“异常处理”的假象：</p>\n<blockquote>\n<p>C++程序员在异常或错误返回代码谁对谁错的问题上存在着一个古老的争论。Niklaus Wirth 认为异常就是另一种 GOTO，因此在他的语言中不支持异常。Haskell 用一种折中的方式解决了这个问题：函数返回错误码，但是错误码的处理不会使代码变丑。</p>\n</blockquote>\n<p>（译注：Niklaus Wirth，Pascal 之父，1984年图灵奖获得者。）</p>\n<p>这里的技巧在于，Haskell 仍然支持熟悉的 <code class=\"language-text\">throw</code> 和 <code class=\"language-text\">catch</code> 模式，但是使用 Monad 而不是控制流来实现。</p>\n<p>虽然 Rust 也使用错误码，但它提供了一种函数式的错误类型。例如，在 Go 语言中，我们有一个bar函数：我们在其中调用 <code class=\"language-text\">foo</code> 函数，并且简单地把foo的错误传播回调用者：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> value<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> err\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Use value ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 Rust 中，如果想写的比较长，那么与 Go 相比并没有更加简洁。下面的代码对于 C 语言程序员来说可能像是在看外语，因为我们使用了模式匹配的语法（这是个问题，但不那么严重）。如果你熟悉函数式编程，那么你应该马上就能理解这段代码，它会时刻提醒你需要处理错误：</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rust line-numbers\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Error</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">match</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token comment\">/* Use value ... */</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">return</span> <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>不过 Rust 做的更好之处在于：它提供了一个 <code class=\"language-text\">try!</code> 宏，减少了不必要的繁文缛节，上面那一堆代码就变成了一句：</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rust line-numbers\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Error</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Use value ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这简直就像是个世外桃源。不过确实，这种方法仍然存在我们提到的性能问题，但它在所有其他的方面都做得非常好。此外，只有这一种模型还不够——我们还需要快速失败（Fail-Fast），即“放弃”（Abandonment）——不过就像我们马上会介绍的，Rust 的方式比其他任何广泛应用的、基于异常的模型都要好。</p>\n<h3 id=\"异常\" style=\"position:relative;\"><a href=\"#%E5%BC%82%E5%B8%B8\" aria-label=\"异常 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>异常</h3>\n<p>异常的历史有点意思。在这段旅途上，我花费了不计其数的时间跟随工业界的步伐重新走了一遍，包括读了一些古老的论文——比如1975年的经典：<a href=\"https://www.cs.virginia.edu/~weimer/2006-615/reading/goodenough-exceptions.pdf\">Exception Handling: Issues and a Proposed Notation </a>。除此之外我还参考了几种其他语言的实现方式：Ada、Eiffel、Modula-2和3、ML、以及最受启发的， <a href=\"https://csg.csail.mit.edu/pubs/memos/Memo-155/Memo-155-3.pdf\">CLU</a>。很多论文对这段漫长而艰辛的历史的总结要比我讲的好，所以我就不在这里多说了。我会主要讲述为了构建高可靠的系统，哪些方法好用、哪些方法不行。</p>\n<p>在开发错误模型的时候，可靠性是上面列举的几个需求当中最重要的。如果你不能合理地处理故障（Failure），根据定义，你的系统就称不上可靠。正常来说，操作系统需要可靠，然而最常见的模型——不受检查的异常——在这一方面差无可差，不能再差。</p>\n<p>由于这些原因，大多数高可靠的系统使用返回码来取代异常。这使得调用者能够进行局部分析并根据不同情况分别应对发生的错误。</p>\n<h4 id=\"不受检查的异常unchecked-exceptions\" style=\"position:relative;\"><a href=\"#%E4%B8%8D%E5%8F%97%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8unchecked-exceptions\" aria-label=\"不受检查的异常unchecked exceptions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>不受检查的异常（Unchecked Exceptions）</h4>\n<p>快速回顾一下。在一个不受检查的异常模型中，你可以throw或是catch异常，而异常并不是类型系统或函数签名的一部分。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token comment\">// Foo 会抛出一个未处理的异常:</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Bar 调用 Foo, 并且处理了那个异常:</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>Exception e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Handle the error.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Baz 也调用了 Foo, 但是没有处理那个异常:</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 异常会继续抛给调用者</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个模型里，任何函数调用——有时甚至是任何 <em>语句</em> ——都可以抛出一个异常，把控制流导向了不知道什么地方。没有任何标注、或是类型系统的数据能够辅助分析。所以结果是，在抛出异常的时候，任何人都很难分析出程序的状态，也很难说清在异常向调用栈上方抛出的时候程序的状态如何改变（在一个并发程序中，这可能会跨越线程之间的鸿沟），同样很难说清异常是否会被 catch，以及它被 catch 时的状态。</p>\n<p>不过，分析程序状态还是可以一试的。这需要去读 API 的文档、做一些代码审计、严重依赖于 Code Review，并且还需要一些运气。编程语言不会给你提供丝毫帮助。由于故障很少发生，这种模型似乎并不像它听起来那么烂。我的结论是：这就是为什么在工业界很多人认为不受检查的异常“足够好”，因为这些东西在执行正常的情况下不会映入你的眼帘，而且由于大多数人在非系统程序里不会编写非常健壮的错误处理程序，这使得\n通常情况下， 直接抛一个异常能够使你最快地摆脱困境。Catch 住异常然后继续执行的话，程序往往也能正常工作。无害就不受罚。从统计上来讲，程序能“工作”。</p>\n<p>也许统计意义上的“正确”对于脚本语言来说是 OK 的，但对于最底层的操作系统来说，或者对于任何关键任务程序和应用来说，它不是一个合适的方案。我相信这没什么争议。</p>\n<p>由于异步异常的存在，.NET 的处境非常糟糕。C++ 也有着所谓的“异步异常”：这些故障是由硬件错误出发的，例如非法访问。然而在 .NET 里，这一部分肮脏不堪：任何一个线程都可以让代码中的任何地方发生故障（Failure），甚至可以在一个赋值语句的左右操作数之间！所以在源代码中看起来像是原子操作的地方，其实不是。 关于这个话题，<a href=\"https://joeduffyblog.com/2005/03/18/atomicity-and-asynchronous-exception-failures/\">我在 10 年前阐述过</a>，但如今它仍然存在。不过这个问题已经被不那么严重了，因为 .NET 终于逐渐认识到线程终止是有问题的。新的 CoreCLR 甚至不再有 AppDomain，新的 ASP.NET Core 1.0 也不会在像以前那样终止一个线程了。但是相关的 API 仍然存在。</p>\n<p>C## 的主设计师 Anders Hejlsberg 有一段非常有名的采访，叫做 <a href=\"https://www.artima.com/intv/handcuffs.html\">The Trouble with Checked Exceptions</a>。从一个系统程序员的角度来看，大部分的论断都会让你抓耳挠腮。下面这一段话足以证明 C## 的目标群体是RAD 开发人员了：</p>\n<blockquote>\n<p>Bill Venners：但是即便在一个使用不受检查的异常模型的语言里，你不是也同样 break 了他们的代码吗？如果 foo的新版本抛出了一个新的异常，使用者应该知道他们需要来处理这个新异常。他们的代码不也是被在写代码时没有纳入考量的异常破坏了吗？</p>\n<p>Anders Hejlsberg：不。因为在大多数情况下，人们不在乎。他们不会处理任何异常。在消息循环的最底层，有一段错误处理程序，这段程序会弹出一个框框说“XX出错了”然后继续执行。程序员们总是随意地写上try finally，所以当异常发生后还是可以保持程序的正确性，但他们真的对处理异常不敢兴趣。</p>\n</blockquote>\n<p>这让我想起了 Visual Basic 里面的 <code class=\"language-text\">On Error Resume Next</code>，以及 Windows Forms 自动捕捉并忽略应用程序的异常然后尝试继续执行。我不是在指责 Anders 的观点；相反，鉴于 C## 的广泛流行，我确信在那个时间、那个环境，这是一个正确的决定。但是它显然不能用来编写一个操作系统。</p>\n<p>C++ 至少还尝试过通过 <a href=\"https://en.cppreference.com/w/cpp/language/except_spec\"><code class=\"language-text\">throw</code> 异常规范</a>（throw exception specifications）来改善不受检查的异常。不幸的是，这个功能依赖于动态执行，这就直接给这个功能敲响了丧钟。</p>\n<p>如果我有一个函数 <code class=\"language-text\">void f() throw(SomeError)</code>，<code class=\"language-text\">f</code> 的函数体仍然可以调用抛出其他异常的函数。同样，如果我使用 <code class=\"language-text\">void f() throw()</code> 声明了 <code class=\"language-text\">f</code> 不会抛出异常，他仍然有可能调用会抛出异常的函数。为了实现声称的合约，编译器和运行时必须确保：如果这种情况发生，需要调用 <code class=\"language-text\">std::unexpected</code> 以确保进程终止。</p>\n<p>我不是唯一一个发现这个设计是个错误的人。throw已经被抛弃了。WG21 文件 <a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3051.html\">Deprecating Exception Specifications</a> 详细描述了 C++ 是如何在这条路上停下来的。下面是这份文件的开篇陈述：</p>\n<blockquote>\n<p>异常规范已经被证明了在实践中几乎毫无用处，同时还为程序增加了可见的负担。</p>\n</blockquote>\n<p>作者列举了 3 条放弃支持 <code class=\"language-text\">throw</code> 的原因，其中两条都与动态执行有关：运行时检查（以及与其相关的不透明的失败模式）和运行时的性能负担。第三条原因是，缺乏与普通代码的协调性，这应该通过合适的类型系统来处理（当然需要付出一定的代价）。</p>\n<p>然而，解决这个问题的手段却依赖于另一个动态构建的概念—— <code class=\"language-text\">noexcept</code> 标识符——而它在我眼里，跟上一个问题一样糟糕。</p>\n<p>“异常安全”是一个在 C++ 社区经常讨论的话题。它清晰地从调用者的角度根据调用会产生的影响对函数进行划分，包括是否会失败、程序状态的转移以及内存管理。函数调用分为四种类型：<em>no-throw</em> 意味着之前的程序状态不会改变，而且不会有异常发生；<em>strong safety</em> 意味着状态的修改是原子性的，失败不会造成状态部分修改或是破坏不变量（Invariant）；<em>basic safety</em> 意味着虽然这个函数可能会部分地修改程序状态，但不变量还是会保证正确，同时也不会发生内存泄漏；最后，<em>no safety</em> 意味着一切皆有可能。</p>\n<p>（译注：不变量（Invaraint）指的是某些程序状态，它们应当始终满足约定的条件。例如，如果约定了栈顶指针始终指向栈顶，no-throw、strong safety、basic safety 函数调用都应当能够保证不论发生什么情况，栈顶指针仍然指向栈顶。下文还会有相关内容。）</p>\n<p>这种分类方法非常好，如果你希望严格要求一个函数在发生错误时的行为，我建议你使用这种或是类似的方法对函数进行分类。就算你在使用错误码模型，这种分类也是有好处的。不过问题在于，当一个系统使用了不受检查的异常模型时，几乎不太可能遵循上述的准则。只有当一个函数处在叶子节点的位置，只调用了一些小的、便于审计的函数时，这些准则才可行。想想就知道了：为了能在所有地方都确保 strong safety，你需要考虑所有的函数调用抛出异常的可能性，然后把这段代码安全地保护起来。这通常意味着编程时需要小心谨慎、信任英语文档（也就是说计算机无法检查）、只调用noexcept函数，或是心中默默祈祷。RAII （以及更现代的智能指针）能够帮助我们解决内存泄漏问题，因此实现 basic safety 可以相对轻松一点。然而，避免破坏不变量仍然是一个麻烦事。这篇文章 <a href=\"https://ptgmedia.pearsoncmg.com/images/020163371x/supplements/Exception_Handling_Article.html\">Exception Handling: A False Sense of Security</a> 很好地总结了这这些问题。</p>\n<p>对于 C++ 来说，真正的解决方案非常容易想到，而且也很直接：对健壮的系统程序来说，不要使用异常。这是 Embedded C++ 所采用的方案，也是无数实时系统和关键任务系统的 C++ 准则，例如 NASA 的喷气推进实验室所也采用这种方案。<a href=\"https://www.youtube.com/watch%3Fv%3D3SdSKZFoUa8\">C++ on Mars sure ain’t using exceptions anytime soon</a>。</p>\n<p>如果这样的话，假设你可以安全地避免使用异常，并且像 C 语言一样只返回错误码，有什么不好吗？</p>\n<p>整个 C++ 的生态都在使用异常。为了遵循上面提到的方案，你必须避免使用异常——这是这门语言中非常重要的部分，也就导致了无法使用 C++ 生态环境中的很多库。想使用 STL？不行，它用了异常。想用 Boost？不行，它用了异常。你的内存分配器也很可能会抛出bad_alloc异常，等等。这导致了很多人都会 fork 一套已有的库，然后魔改去掉异常。例如 Windows 内核就有一套它自己的不使用异常的 STL。生态系统的这种分歧既让人难受，又难以为继。</p>\n<p>这简直就是一团乱麻，相当多的语言都使用了不受检查的异常模型。结论很明显，这些语言不适合编写底层、高可靠的系统代码。（我这么坦率肯定会得罪很多 C++ 程序员。）在 Midori 上写了很多年代码之后，再回过头来使用不受检查的异常模型来写程序，对我简直就是一种折磨。不过值得“庆幸”的是，还有 Java 这种使用受检查异常模型的语言，也许我们可以从中学到点什么？</p>\n<h4 id=\"受检查的异常checked-exceptions\" style=\"position:relative;\"><a href=\"#%E5%8F%97%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8checked-exceptions\" aria-label=\"受检查的异常checked exceptions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>受检查的异常（Checked Exceptions）</h4>\n<p>啊哈，受检查的异常。它就像一个碎布娃娃，每个 Java 程序员、甚至非 Java 程序员都想凑上去揍他一顿！不过在我看来，这不太公平，毕竟还有个不受检查的异常在那垫底呢。</p>\n<p>在 Java 中，你能知道一个方法所能抛出的大部分异常，因为它必须显示地声明出来：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">FooException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BarException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>这样的话，<code class=\"language-text\">foo</code> 的调用者就能够知道它可能会抛出FooException或者BarException。程序员在调用它时必须选择：1）将这些异常原封不动地再抛给上层；2）catch 住这些异常然后处理；3）把这些异常转换为其他异常然后再抛出（很有可能会“不小心”抹掉异常的类型）。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// 1) 原封不动地抛给上层：</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">FooException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BarException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 2) Catch 住然后处理</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FooException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Deal with the FooException error conditions.</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BarException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Deal with the BarException error conditions.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 3) 把异常的类型转换一下然后抛出:</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这与我们所期望的模型很接近了。但是，Java 的模型仍然在某些方面有所不足：</p>\n<ol>\n<li>\n<p>异常也用来传递不可恢复的 bug，比如空指针解引用、零除错误，等等。</p>\n</li>\n<li>\n<p>其实你没办法真正知道一个方法能抛出的所有异常。这得归功于我们的RuntimeException小朋友。由于 Java 用异常来处理所有的错误（包括 Bug），语言的设计者们已经察觉到了大家会对这些异常的显式说明感到恼怒。所以他们就引入了一类不受检查的异常，也就是说，一个方法可以不加说明地抛出这些异常，调用者调用这个方法时也可以不做任何修改。</p>\n</li>\n<li>\n<p>尽管异常类型是函数签名的一部分，在方法调用时却没什么东西来指明这个方法是否会抛出异常。</p>\n</li>\n<li>\n<p>大家都烦它。</p>\n</li>\n</ol>\n<p>最后一点很有意思。在后面介绍 Midori 的错误模型时，我们会再回来回顾这一点。简单来说，人们对 Java 的受检查异常模型的厌恶感来自于前面那 3 点。最终的结果是，这个异常模型似乎在可靠性和易用性两个方面都是最差的。它并没有对写出高可靠的代码提供了什么帮助，同时还非常难用。在代码里你只能写下一大堆啰嗦的语句，而得到的好处却寥寥无几。而且需要对接口进行版本控制简直蛋疼。我们后面会看到，这个模型还有改进的空间。</p>\n<p>“版本控制”这一点值得多说两句。如果你只抛出一种类型的异常，那么它跟错误码方案没什么区别。一个函数要么失败，要么成功。如果你的 API 的第一个版本不会失败，而第二个版本可能会失败，那么这两个版本就是不兼容的。我认为这种思路其实是正确的。API 的失败模型是 API 设计最重要的部份之一，理应与调用者说清楚，这就好像你不会悄悄地、不跟调用者说明白就把一个 API 的返回值类型改了一样。后面会有更多关于这个话题的讨论。</p>\n<p>Barbara Liskov 在她1979年的论文 <a href=\"https://csg.csail.mit.edu/pubs/memos/Memo-155/Memo-155-3.pdf\">Exception Handling in CLU</a> 中描述了 CLU 使用的一种很有意思的方法。他们很关注“语言学”——换句话说他们想要做出一门大家都喜欢的语言。在 CLU 中，调用方检查以及传播错误的方式跟错误码方案很像，同时他们的编程模型还一点声明式的味道，也就是我们现在所熟知的异常。最重要的是，<code class=\"language-text\">signal</code>（即 <code class=\"language-text\">throw</code>）是受检查的。程序如果抛出了一个没有写明的 <code class=\"language-text\">signal</code>，他们还提供了一种很方便的方式来结束程序。</p>\n<h4 id=\"异常的通病\" style=\"position:relative;\"><a href=\"#%E5%BC%82%E5%B8%B8%E7%9A%84%E9%80%9A%E7%97%85\" aria-label=\"异常的通病 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>异常的通病</h4>\n<p>大多数异常系统都有几点很重要的事情做错了，不论是受检查的还是不受检查的异常。</p>\n<p>首先，抛出一个异常总是很慢，不可思议的慢。这通常与收集栈信息有关。在一些托管平台上，收集栈信息需要遍历元数据，以便能够创建函数符号名。如果一个错误被抓住之后被合理地处理了，我们就根本不需要这些信息！诊断信息最好在与日志和诊断相关的基础设施里来实现，而不是在异常系统里。这两点问题是同时存在的。不过，要真正能够满足上面提到的诊断需求，还是需要有人能够恢复栈信息的——永远不要小看 printf 调试大法，以及栈信息对它的重要性。</p>\n<p>其次，异常会极大地损害代码质量。我在<a href=\"https://joeduffyblog.com/2015/12/19/safe-native-code/\">最近的一篇文章</a>中提到过这一点，另外还有<a href=\"https://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.116.8337%26rep%3Drep1%26type%3Dpdf\">很多论文</a>从 C++ 的角度讨论过这个问题。缺少静态类型信息，意味着编译器很难对控制流进行建模，进而导致编译器更加倾向于保守地优化代码。</p>\n<p>异常系统的另一个问题在于它鼓励粗粒度地处理错误。很多人喜欢返回错误码的方案，就是因为调用一个函数后就必须进行错误处理。（我也喜欢这一点。）而在异常处理系统中，人们经常用一个的try/catch块包住一大坨代码，而不是小心地去应对每一处可能出现的错误。这样的代码很脆弱，而且几乎都是错的；就算现在看起来没问题，将来等代码一重构，问题就会暴露出来。这个问题很大程度上是因为语言没有提供合适的语法导致的。</p>\n<p>最后，<code class=\"language-text\">throw</code> 的控制流通常都不可见。就算是在 Java 里，异常是方法签名的一部分，也不可能通过分析函数体就能准确知道异常是从哪抛出来的。不明显的控制流带来的问题就跟 <code class=\"language-text\">goto</code>、<code class=\"language-text\">setjump/longjmp</code> 一样大，增加了编写可靠的代码的难度。</p>\n<h2 id=\"小结\" style=\"position:relative;\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-label=\"小结 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>小结</h2>\n<p>在继续到下一部分之前，我们先来总结一下吧：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>优点</th>\n<th>缺点</th>\n<th>不是很好的地方</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>错误码</td>\n<td><ul><li>所有可能失败的函数都会显式标明</li><li>在调用时显式处理所有的错误</li></ul></td>\n<td>你可能会忘记检查错误码不发生错误时代码的性能会有所影响</td>\n<td>易用性不太好</td>\n</tr>\n<tr>\n<td>所有的异常系统</td>\n<td>语言原生支持</td>\n<td><ul><li>性能差，其实本可以做的更好一点</li><li>错误处理通常都不是局部处理，就像 goto 一样，关于错误的信息比较少</li></ul></td>\n<td></td>\n</tr>\n<tr>\n<td>不受检查的异常</td>\n<td>它有助于快速开发（Rapid Development）, 即错误处理不是最重要的事情</td>\n<td>任何东西都可能会失败，编译器也不会有警告</td>\n<td>可靠性很差</td>\n</tr>\n<tr>\n<td>受检查的异常</td>\n<td>所有可能会失败的函数都会显式标注</td>\n<td><ul><li>在函数调用处，函数是否会失败、错误如何传播并不明确</li><li>系统允许某些异常不受检查（即不是所有的错误都是显式声明的）</li></ul></td>\n<td>遭人恨（至少 Java 是这样）</td>\n</tr>\n</tbody>\n</table>\n<p>如果我们能集成所有优点、再扔掉所有缺点，岂不美哉？</p>\n<p>这是我们向前迈出的一大步，不过这还不够。我们第一次觉得思路清晰起来，能把事情都想清楚。对于某一类的错误，这些方法一个合适的都没有！</p>"},"childMdx":null}},{"node":{"id":"53351b04-e78f-5e5d-b7c5-fc44e1ce8617","relativePath":"the-error-model/2-bugs-arent-recoverable-errors.md","childMarkdownRemark":{"fields":{"slug":"/the-error-model/2-bugs-arent-recoverable-errors/"},"frontmatter":{"title":"二、Bug 不是可恢复错误！"},"html":"<p>关于可恢复错误和 Bug，我们之前提到过二者之间明确的界限：</p>\n<ul>\n<li>\n<p>可恢复错误通常都是程序化数据验证的结果。有时候程序会检查这个世界的状态，但认为当前的状态不能接受——比如解析一些标签语言、解析用户在网站上的输入、或是网络不稳定等等。在这些情况下，程序应该恢复执行。写程序的开发人员必须提前安排好要怎么处理这些情况，因为不论我们怎么做，都避免不了这些状况。程序给出的响应可能是给用户返回一些信息、重试或者直接放弃这个操作。虽然它们也被称作“错误”，但这些错误都是可预测的，而且对于这些状况，程序通常是有准备的。</p>\n</li>\n<li>\n<p>Bug 是一类程序员无法预测的错误。用户输入没有被正确地验证，或是逻辑写错了，等等。这类问题一旦发生，就会极大地损害程序状态；然而它们有时候很隐蔽，甚至要等到它们让别处的代码出现了问题后，才会被间接发现。由于程序员并没有想到会发生这些情况，我们就前功尽弃了。那段有问题的代码所能修改的所有的数据结构都可能已经损坏了，同时因为这些问题没有被直接检测到，很大可能所有的东西都已经出了问题。根据你使用的语言所提供的隔离性，也许整个进程都已经被污染了。</p>\n</li>\n</ul>\n<p>这些区别至关重要。令人惊讶的是，很多系统完全不区分它们，至少没有以一种原则性的方式来区分！正如我们所见，Java、C#以及很多动态语言使用异常、 而 C 和 Go 使用错误码，来同时应对这两种错误。C++ 则使用了一种混合的方式，这取决于使用者如何选择，但常见的情况是一个项目只选择一种方法使用。通常来说，没什么语言建议使用两种不同的方法来处理错误。</p>\n<p>考虑到 Bug 本身是不可恢复的，我们不需要尝试去恢复执行。在运行时检测到的所有 Bug 需要触发“<em>放弃</em>”，这是 Midori 中的术语，用来指代“<a href=\"https://en.wikipedia.org/wiki/Fail-fast\">Fail-Fast</a>”。</p>\n<p>上面提到的所有系统都提供了类似于放弃的机制。C# 提供了 <code class=\"language-text\">Environment.FailFast</code>；C++ 提供了 <code class=\"language-text\">std::terminate</code>；Go 提供了 <code class=\"language-text\">panic</code>，Rust 也有 <code class=\"language-text\">panic!</code>，等等。它们都能让你迅速脱离当前的上下文。上下文的范围取决于系统——比如 C# 和 C++ 会结束进程，Go 会结束当前的 Goroutine，Rust 会结束当前的线程，还可选附带一个错误处理程序来拯救整个进程。</p>\n<p>虽然我们对放弃机制的使用比一般语言更多，但我们显然不是第一个注意到这种方案的。这篇 <a href=\"https://wiki.haskell.org/Error_vs._Exception\">Haskell 文章</a>就讲的非常好：</p>\n<blockquote>\n<p>我曾经参与过编写一个 C++ 库。有一个开发人员对我说，开发者们分成了两派：一派喜欢使用异常，一派喜欢使用返回值。在我看来，返回值派赢得了这场战争的胜利。然而，我却觉得他们所讨论的论点就是错误的：异常和返回值在表达能力上是等价的，它们不应该用来表示错误。很多返回值包含了这样的常量定义：ARRAY_INDEX_OUT_OF_RANGE，但我很不解：如果在调用其他函数时遇到了一个这样的错误，我的函数究竟能做点什么呢？需要发一封邮件给我吗？当然，这个错误码还可以返回给更上层的函数，但是更上层的函数也会不知所措。更糟糕的是，由于我不清楚所有的细节，我只能假设我所调用的所有函数都会返回数组越界的错误。我的结论是：数据越界是一种（编程）错误，在运行时它无法被处理或是修复，只能被开发人员手工修正。因此它不应该使用返回值来表示，而应该使用断言（asserts）。</p>\n</blockquote>\n<p>我有点怀疑只放弃细粒度的可变共享内存（例如 Goroutine、线程之类的东西）的正确性，除非你的系统对潜在损害的范围有所保证。不管怎么说，有这些机制就是件好事！这说明了在这些语言里实践“放弃”原则是可行的。</p>\n<p>然而，如果想让这种方法在大规模的程序上也可行，我们还需要一点架构设计上的思考。我敢肯定你现在在想：“如果在我的 C# 程序里，每遇到一次空指针错误就结束掉整个进程，我肯定会被客户怼的”，或者“这根本就不叫可靠！”。可靠性，也许并不是你想的那样。</p>"},"childMdx":null}},{"node":{"id":"b2703248-3e96-560a-ac72-61d2e669fd2c","relativePath":"the-error-model/3-reliability-fault-tolerance-and-isolation.md","childMarkdownRemark":{"fields":{"slug":"/the-error-model/3-reliability-fault-tolerance-and-isolation/"},"frontmatter":{"title":"三、可靠性、容错性和隔离性"},"html":"<p>在继续下一个话题之前，我们需要明确的是：<del>猫咪总是四脚朝地</del> 故障（Failure）总是会发生的。</p>\n<h2 id=\"如何构建一个可靠的系统\" style=\"position:relative;\"><a href=\"#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%9D%A0%E7%9A%84%E7%B3%BB%E7%BB%9F\" aria-label=\"如何构建一个可靠的系统 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>如何构建一个可靠的系统</h2>\n<p>大家通常认为，一个可靠的系统就是能够系统性地证明故障不可能发生。直觉上看，似乎很对。但它存在一个问题：在有限的条件下，这是不可能的。如果你能在可靠性这一点上花上上亿美刀，情况也许会有所改观；此外，也可以使用像 <a href=\"https://en.wikipedia.org/wiki/SPARK_%28programming_language%29\">SPARK</a> （基于合约（Contracts）的 Ada 扩展）之类的语言来形式化地证明每行代码的正确性。然而，<a href=\"https://en.wikipedia.org/wiki/List_of_software_bugs\">经验表明</a>这种方法也不是万无一失。</p>\n<p>我们选择了接受这种现状。当然，我们必须尽可能地减少故障的发生，错误模型必须能够让故障透明化，并且易于处理。但是更重要的是，你需要在系统设计上下功夫，使得就算某个部分出现了问题，整个系统也还能够工作；同时还要让系统能够优雅地恢复出错的部分。这其实在分布式系统中是常识，有什么特别之处吗？</p>\n<p>一切的前提是，我们要把一个操作系统看作是各个协作进程组成的分布式网络，就像由微服务组成的分布式集群、或是互联网本身一样。主要的差别包括延迟、信任级别、关于位置、身份的各种假设，等等。在一个高度异步的、分布式的、IO密集的系统中，故障是必然发生的。我的印象是，在很大程度上，由于宏内核的成功，我们还没有实现“操作系统作为一个分布式系统”的飞跃。然而，一旦你这样看待一个操作系统，很多设计准则都会发生改变。</p>\n<p>在大多数分布式系统中，系统架构都会认为一个进程发生故障是不可避免的。从而我们需要花大力气来避免级联故障，定期记录日志，并且将程序和服务设计为允许重新启动的。</p>\n<p>一旦你接受了这样的设定，很多事情都变得不一样了。</p>\n<p>举个例子，隔离性就变得极端重要。Midori 的进程模型鼓励轻量级、细粒度的隔离。结果就是，程序、甚至是现代操作系统中的“线程”之间都是独立分隔的实体。相比于在同一个地址空间中共享可修改的状态，这样的设计可以更容易地在某个实体发生故障时提供保护。</p>\n<p>高隔离性同样有利于实现简洁性。Butler Lampson 的经典论文\n<a href=\"https://research.microsoft.com/pubs/68221/acrobat.pdf\">Hints on Computer System Design</a> 探索了这一方面。我非常喜欢 Hoare 的这句话：</p>\n<blockquote>\n<p>可靠性不可避免的代价就是简单化<br>\nC. Hoare</p>\n</blockquote>\n<blockquote>\n<p>（译注：C. A. R. Hoare (或 Tony Hoare)，发明了快速排序、霍尔逻辑形式验证等算法和系统）</p>\n</blockquote>\n<p>通过把程序分成更小的部分，每一个部分都允许成功或失败，他们的状态管理可以变得更加简单。结果就是，从故障中恢复也变得更加容易。在我们的语言中，可能发生故障的地方都会显式说明，这进一步保证了内部状态机的正确性，同时能够点明哪些地方会与混乱的外部世界发生联系。在这个世界上，局部故障的代价并没有那么可怕。我并没有过分地重视这一点——架构方面提供的隔离性，是我后面描述的所有语言功能的基础。</p>\n<p>Erlang 已经非常成功地把这种属性加入到了语言的基础部分。就像 Midori 一样，它使用了轻量级进程，通过消息传递互相连接，并且鼓励容错架构设计。一个通用的模式叫做“Supervisor”，有一些进程会负责监控和重启其他发生故障的进程。<a href=\"https://ferd.ca/the-zen-of-erlang.html\">这篇文章</a>非常好地阐述了这种理念——“Let it crash”，同时还推荐了一些用来构建可靠的 Erlang 程序的实用技术。</p>\n<p>关键之处并非是如何防止故障，而是知道如何应对故障。一旦这样的架构建立了起来，你就会相信它的确能够正常工作。对于我们来说，我们进行了长达一周的压力测试，以确保我们的系统在整体上足够稳定，即便在这期间某些进程可能会因为故障而崩溃、重启。这让我想起了类似于 Netflix 的 <a href=\"https://github.com/Netflix/SimianArmy/wiki/Chaos-Monkey\">Chaos Monkey</a> 系统，它会随机杀掉集群中的某些机器来确保服务的运行状况良好。</p>\n<p>随着分布式计算越来越流行，我很期待能够有更多人能够采用这样的思想。比如，在一个微服务的集群中，在单一容器上发生的故障通常能够被外部的集群管理软件无缝地处理（例如 Kubernetes、Amazon EC2 Container Service、Docker Swarm等等）。所以我这篇博客所描述的内容可能对写出可靠的 Java/Node.js/Javascript/Python/Ruby 服务有所帮助，但不幸的是你很可能需要跟你使用的语言作一番斗争。为了在出现问题时能够继续勉强工作，你可能需要写上一大堆的代码。</p>\n<h2 id=\"放弃\" style=\"position:relative;\"><a href=\"#%E6%94%BE%E5%BC%83\" aria-label=\"放弃 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>放弃</h2>\n<p>就算进程很轻量、隔离得很好、重启很简单，仍然会有人认为遇到 bug 就直接结束进程的做法太过激进。这也是能够理解的。我就来试着说服你吧。</p>\n<p>如果你想要构建一个健壮的系统，当遇到 bug 时选择继续执行是很危险的。如果一个程序员没有考虑过某些状况的发生，谁都不知道那些代码会不会继续正常工作。重要的数据也许已经被破坏成不正确的状态了。举一个极端（也许有点傻）的例子：某段程序本来是要对你的银行存款向下取整，现在却开始向上取整了。</p>\n<p>也许你认为放弃的粒度应该更小，这就有点复杂了。举例来说，假如你的进程遇到了 bug 并且出现了故障，这个 bug 可能是由于某些静态变量的值出错导致的。尽管其他的线程看起来没问题，你也没办法笃定它们一定不会被影响。除非你的系统支持某些特性——比如语言提供的隔离性、各个独立线程中可访问的顶层对象的隔离性、等等，否则最安全的假设就是只能扔掉整个地址空间，其他的操作都是有风险、不可靠的。由于 Midori 中的进程非常轻量，放弃一个 Modiri 进程就像在其他的系统中放弃一个线程一样。我们的隔离模型能够确保这样做的可靠性。</p>\n<p>我必须得承认，“放弃”范围的界定可能产生滑坡谬误。可能在世界上所有的数据都已经坏掉了，你怎么知道放弃这个进程就够了呢？这里有一个很明显的区别：进程的状态是提前设计好的、非持久化的。在一个设计良好的系统中，进程可以随时被丢弃然后重新创建。的确，一个 bug 可以破坏外部持久化的状态，但如果这种更严重的问题发生了的话，你就需要使用不同的方法来处理了。</p>\n<p>我们可以看一看容错系统的设计来了解更多的背景。放弃（快速失败）在容错系统中已经是一个非常常见的技术了，我们也可以把这一领域的大多数经验应用到普通的程序和进程中。也许最重要的一点就是定期记录日志、定期在检查点记录宝贵的持久化状态。1985年 Jim Gray 的发表了一篇论文\n<a href=\"https://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.110.9127%26rep%3Drep1%26type%3Dpdf\">Why Do Computers Stop and What Can Be Done About It?</a> 详细地描述了这种观点。随着程序不断地迁入云服务、并且激进地划分为更小的、互相独立的服务，这种明确区分非持久化和持久化的状态越发显得重要起来。这种潮流也影响了软件的开发方式，如今“放弃”在现代架构中也变得更加容易实现。同时，放弃也有助于防止数据的损坏，因为 bug 在下一个检查点到来之前就会被检测到，程序也不会在错误状态下继续执行。</p>\n<p>对于 Midori 内核中的 Bug，我们的处理方式有所不同。例如，微内核的 bug 相比于用户态进程的 bug 来说，破坏性更大，最安全的方法是放弃整个“域（Domain）”（即地址空间）。幸运的是，你所了解的大多数典型的“内核”功能——调度器、内存管理、文件管理、网络栈、甚至设备驱动——都在用户态以独立进程的方式执行。这些模块中的错误可以用上文中提到的通常方法解决。</p>"},"childMdx":null}},{"node":{"id":"f4e18356-95f4-5df5-bb34-46ea55bf229a","relativePath":"the-error-model/4-bugs-abandonment-assertions-and-contracts.md","childMarkdownRemark":{"fields":{"slug":"/the-error-model/4-bugs-abandonment-assertions-and-contracts/"},"frontmatter":{"title":"四、Bugs：放弃、断言和合约"},"html":"<p>在 Midori 中，很多类型的 bug 都可能会触发放弃：</p>\n<ul>\n<li>不正确的类型转换</li>\n<li>尝试对null指针解引用</li>\n<li>尝试越界访问数组</li>\n<li>零除错误</li>\n<li>算数计算发生意外的上溢/下溢</li>\n<li>内存不足栈溢出</li>\n<li>显式放弃</li>\n<li>合约失败</li>\n<li>断言失败</li>\n</ul>\n<p>我们最根本想法是，这里每一种错误都是不可恢复的。让我们逐一进行讨论。</p>\n<h2 id=\"普通的老-bug\" style=\"position:relative;\"><a href=\"#%E6%99%AE%E9%80%9A%E7%9A%84%E8%80%81-bug\" aria-label=\"普通的老 bug permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>普通的老 Bug</h2>\n<p>上面那些情况中，有一些是公认的程序 Bug。</p>\n<p>很显然，不合法的类型转换、尝试对null解引用、数组越界访问、零除错误都是程序的逻辑错误，这些都是非法操作。我们在下文会看到，这些操作也有可能被认为是合法操作（比如当一个数除以零时，也许你想要把结果表示为 NaN）；不过我们先默认假设这些就是 Bug。</p>\n<p>很多程序员都会接受这个结论。使用“放弃”来应对这些 Bug，使得这些 Bug 能够在开发阶段就被快速发现、快速修正。放弃确实有助于提高写代码的生产力。一开始我还有点惊讶，但确实很有道理。</p>\n<p>而另一方面，上面其他的情况是否属于 Bug，则是个主观问题。我们必须决定当出现这些状况时程序的默认行为、可能还需要提供程序化的控制方法。我们当时还为此争论不休。</p>\n<h3 id=\"算数计算上溢下溢\" style=\"position:relative;\"><a href=\"#%E7%AE%97%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%8A%E6%BA%A2%E4%B8%8B%E6%BA%A2\" aria-label=\"算数计算上溢下溢 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>算数计算上溢/下溢</h3>\n<p>算数计算发生了意外的上溢/下溢究竟算不算一种 Bug，这就是一个有争议的问题。在不安全的系统里，这样的错误经常会导致安全漏洞。我建议你看看国家漏洞数据库，<a href=\"https://web.nvd.nist.gov/view/vuln/search-results%3Fquery%3D%2522integer%2Boverflow%2522%26search_type%3Dall%26cves%3Don\">就能知道有多少漏洞是由这种问题导致的</a>。</p>\n<p>Windows TrueType 字体的语法分析器就曾经在过去的几年里不断地受到这类问题的影响（我们把它 port 到了 Midori，还有性能提升）。语法分析器似乎是这种安全漏洞的重灾区。<a href=\"https://safeint.codeplex.com/\">SafeInt</a> 因此而生，它本质上就是不让你使用语言本身提供的算术计算操作，转而使用这个库提供的受检查的计算操作。</p>\n<p>当然，在这些漏洞中，大多数都跟访问不安全的内存有关。所以你可能会反驳说，溢出在一门安全的语言中没什么害处，应该被允许。然而，基于我们在安全方面的经验，通常当一个程序遇到了意外的上溢/下溢时，继续执行也不会得到正确的结果——简单来说，开发者经常会忽略可能发生的溢出，因此程序执行的结果也就无法预料。这很符合 bug 的定义，而“放弃”就是用来发现这些问题的。压死骆驼的最后一根稻草则是一个哲学问题：当我们面对任何有关正确性的问题时，我们更倾向于站在显式意图这一边。</p>\n<p>因此，所有无标注的上溢、下溢都会被视为 Bug 并触发放弃。这与 C# 的 <a href=\"https://msdn.microsoft.com/en-us/library/h25wtyxf.aspx\"><code class=\"language-text\">/checked</code> 编译选项</a>很类似，只有一点不同：我们的编译器会激进地优化掉冗余的检查。（对于 C# 来说，由于很少有人用到这个开关，代码生成器不会那么激进地删掉插入的检查。）多亏了语言和编译器的协同开发，生成的代码比大多数使用 SafeInt 的 C++ 编译器产生的结果要好。跟 C# 一样，<a href=\"https://msdn.microsoft.com/en-us/library/khy08726.aspx\"><code class=\"language-text\">unchecked</code> 作用域结构</a>可以用来显式指明允许上溢或下溢。</p>\n<p>大多数 C# 和 C++ 程序员第一次听到这个决定时都持反对态度。但尽管如此，我们发现，由算术溢出所触发的放弃，十次有九次都是程序 Bug。剩下的一次是在我们进行了72个小时的压力测试之后发生的——我们不断地使用浏览器、媒体播放器等软件来折磨我们的系统——然后，一些没什么危害的计数器溢出了。我觉得相比于通过压力测试来使得程序更加成熟稳定（比如死锁和竞态条件），直接提前发现问题然后修了它要有意思得多了。</p>\n<h3 id=\"内存不足和栈溢出\" style=\"position:relative;\"><a href=\"#%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%92%8C%E6%A0%88%E6%BA%A2%E5%87%BA\" aria-label=\"内存不足和栈溢出 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>内存不足和栈溢出</h3>\n<p>内存不足（Out-of-Memory，OOM）的情况有点复杂。我们的方法在这当然也是有争议的。</p>\n<p>在内存需要手动管理的情况下，错误码风格是最常见的检查方式：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">X<span class=\"token operator\">*</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>X<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 处理内存申请失败</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这种方式有一个很微妙的好处：内存分配很痛苦、需要思考，因此使用这种技术的程序通常更加节俭、谨慎地使用内存。但这种方式有一个巨大的不足：它极易出错、同时会产生大量的没有经过测试的代码路径（code path）。如果一条代码路径没有被测试过，那么它很容易出问题。</p>\n<p>当内存快要不够的时候，开发人员所采取的措施通常都不够妥当。以我在 Windows 和 .Net Framework 上的经验来看，这就是犯下严重错误的地方，衍生出了极其复杂的编程模型，比如 .Net 中所谓的受限执行区域（Constrained Execution Regions）。一个程序一瘸一拐，连一小块内存都拿不到，很快就会成为可靠性的敌人。<a href=\"https://blogs.msdn.com/b/cbrumme/archive/2003/06/23/51482.aspx\">Chris Brumme 的一篇非常赞的文章</a>讲述了与其有关的故事。</p>\n<p>我们的系统中有一些部分比较难搞，比如在内核的底层，放弃的范围肯定要比单一进程更大。不过我们在尽可能地控制这种代码的规模。系统中的其他部分呢？没错，你肯定猜到了——放弃。优雅而又简洁。</p>\n<p>令人惊讶的是，这种方法似乎并没有带来太多的麻烦，我把大部分原因归功于隔离模型。实际上，根据资源管理的策略的设置，我们也可以有意地让使一个进程“内存不足”进而触发放弃，以此来证明整个系统的健壮性和可恢复性。</p>\n<p>当某一次内存申请失败时，你也可以选择不触发放弃。这其实不太常见，但我们也有机制来支持这种选择。可能最合适的例子是：假如你的程序这一次想要申请 1MB 的内存。这跟平时小于 1KB 的对象内存申请不太一样，开发人员可能会提前考虑到内存不够的情况并作出充分的准备。比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var bb = try new byte[1024*1024] else catch;\nif (bb.Failed) {\n    // 处理内存申请失败\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>栈溢出是这个思路的简单延伸。实际上，由于我们的“异步链接栈”（asynchronous linked stacks）模型，栈内存不足在物理上就等同于堆内存不足，因此处理方法与 OOM 一致也并不令人惊讶。如今很多系统都用这样的方式来处理栈溢出。</p>\n<h2 id=\"断言\" style=\"position:relative;\"><a href=\"#%E6%96%AD%E8%A8%80\" aria-label=\"断言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>断言</h2>\n<p>断言是指在代码中手动检查某些条件必须为真，否则就会触发放弃。与很多系统一样，我们的系统中断言也分为两种：仅在 Debug 模式下的断言和 Release 模式下的断言。然而不同的是，我们使用 Release 断言的时候更多。实际上，断言在我们的代码里随处可见，大多数的方法都有不止一个断言。</p>\n<p>这种实践符合这样的哲学：当运行时遇到 bug 时，把它暴露出来要比继续执行更好。当然，我们的编译器后端知道如何激进地对这些断言进行优化。我们的代码中断言的密度很高，与很多高可靠系统所建议的很类似，比如在 NASA 的论文 <a href=\"https://pixelscommander.com/wp-content/uploads/2014/12/P10.pdf\">The Power of Ten -Rules for Developing Safety Critical Code</a> 中：</p>\n<blockquote>\n<p>规则：代码中断言的密度至少为每个函数2个。断言用来检查在真正执行时不应该发生的反常现象。断言必须没有副作用，应当定义为布尔值检测。<br>\n原因：根据工业界编码工作的统计数据，通常每编写10行到100行代码，单元测试就能发现一个缺陷。发现缺陷的机率随着断言密度的增加而增长。断言也通常作为强防御编码策略（strong defensive coding strategy）所建议的一部分。</p>\n</blockquote>\n<p>如果想要插入断言，只需要简单地调用 <code class=\"language-text\">Debug.Assert</code> 或是 <code class=\"language-text\">Release.Assert</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Debug<span class=\"token punctuation\">.</span><span class=\"token function\">Assert</span><span class=\"token punctuation\">(</span>something<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Debug-only assert.</span>\n    Release<span class=\"token punctuation\">.</span><span class=\"token function\">Assert</span><span class=\"token punctuation\">(</span>something<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Always-checked assert.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们同样实现了与 C++ 中 <code class=\"language-text\">__FILE__</code> 和 <code class=\"language-text\">__LINE__</code> 宏类似的功能，外加 <code class=\"language-text\">__EXPR__</code>，代表了断言中谓语表达式的文本。这样的话由于失败断言而导致的放弃将会包含一些有用的信息。</p>\n<p>在早些时候，我们设计了与现在不同的断言“等级”。一共三级，<code class=\"language-text\">Contract.Strong.Assert</code>、<code class=\"language-text\">Contract.Assert</code>、<code class=\"language-text\">Contract.Weak.Assert</code>。最强的等级表示“始终检查”，中间的等级表示“编译器说了算”、最弱的等级表示“仅在 Debug 模式下检查”。我做了一个很有争议的决定——抛弃这种模型。实际上，我非常肯定，我们组里 49.99% 的人都讨厌我对术语的选择（<code class=\"language-text\">Debug.Assert</code> 和<code class=\"language-text\">Release.Assert</code>），但我始终都觉得这两个词很恰当，它们完美地表明了这两种断言究竟在做什么。旧的分类方法的问题在于，没有人确切地知道什么时候应该检查断言；在我看来，由于好的断言准则对于程序的可靠性极其重要，而断言的使用方法居然会令人困惑，这是我无法接受的。</p>\n<p>在我们把合约（contracts）添加到语言中之后（下文很快就会介绍），我们也尝试过把 <code class=\"language-text\">assert</code> 设计为一个关键字。不过，最终我们还是继续使用了 API 的方式。主要的原因是，与合约不同，断言不是 API 签名（signature）的一部分；同时由于断言很容易以库的形式实现，我们也不确定把它加入到语言当中有什么好处；还有一点，“Debug 模式下的检查”和“Release 模式下的检查”之类的策略，看着就不像一门编程语言应该有的东西。我得承认，就算这么多年过去了，我还是不太确定哪种方式更好一些。</p>\n<h2 id=\"合约\" style=\"position:relative;\"><a href=\"#%E5%90%88%E7%BA%A6\" aria-label=\"合约 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>合约</h2>\n<p>合约是在 Midori 中发现 Bug 的最核心的机制，没有之一。我们是从 <a href=\"https://en.wikipedia.org/wiki/Singularity_%28operating_system%29\">Singularity</a> 开始做起的，它使用的是 Sing#，一门 <a href=\"https://research.microsoft.com/en-us/projects/specsharp/\">Spec#</a> 的变种语言。不过我们很快就换成使用正规的 C# 了，只能把我们想要的东西重新发明一遍。最终我们实现的模型跟最初的模型已经相去甚远。</p>\n<p>多亏了我们的语言对不变性和副作用的理解，所有的合约和断言都被证明了是没有副作用的。这大概是这门语言最大的创新点，我肯定会再写一篇博客讲讲它的。</p>\n<p>跟其他方面一样，我们也受到了很多其它系统的影响。Spec# 是最明显的一个。<a href=\"https://files.ifi.uzh.ch/rerg/amadeus/teaching/courses/ase_fs10/Meyer1992.pdf\">Eiffel 也对我们有很大的影响</a>，尤其是有很多公开发表的研究。另外还有一些其他的研究工作也对我们有所帮助，例如基于 Ada 的 <a href=\"https://en.wikipedia.org/wiki/SPARK_%28programming_language%29\">SPARK</a>、一些实时与嵌入式系统的提议等等。更深入地讲，像<a href=\"https://www.spatial.maine.edu/~worboys/processes/hoare%2520axiomatic.pdf\">霍尔公理语义</a>这样的编程逻辑为所有的一切提供了基础。然而对我来说，最重要的哲学启发来自于 CLU、以及之后的 <a href=\"https://pdos.csail.mit.edu/archive/6.824-2009/papers/argus88.pdf\">Argus</a> 中提供的错误处理方法。</p>\n<h3 id=\"前置条件和后置条件preconditions-and-postconditions\" style=\"position:relative;\"><a href=\"#%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%90%8E%E7%BD%AE%E6%9D%A1%E4%BB%B6preconditions-and-postconditions\" aria-label=\"前置条件和后置条件preconditions and postconditions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前置条件和后置条件（Preconditions and Postconditions）</h3>\n<p>合约最基本的形式就是方法的前置条件，它声明了要调用这个方法所必须满足的条件。通常来说先决条件会用来验证参数。它有时也会用来验证目标对象的状态，不过这非常少见，因为对于程序员来说考虑清楚模态（modality）是一件很困难的事。前置条件基本上就是调用者对被调用者做出的承诺。</p>\n<p>在我们最终的模型中，前置条件使用 <code class=\"language-text\">requires</code> 关键字声明：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Register</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span></span> name<span class=\"token punctuation\">)</span>\n    requires <span class=\"token operator\">!</span><span class=\"token keyword\">string</span><span class=\"token punctuation\">.</span><span class=\"token function\">IsEmpty</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 继续执行，字符串一定不为空</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>一种稍微不太常见的合约就是方法的后置条件。它声明了在这个方法调用之后应有的状态。这是被调用者对调用者做出的承诺。</p>\n<p>在我们最终的模型中，后置条件使用 <code class=\"language-text\">ensures</code> 关键字声明：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token class-name\">ensures</span> Count <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 继续执行，调用者明确知道在方法返回时Count一定0</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在后置条件中，同样可以通过特殊的名字 <code class=\"language-text\">return</code> 来引用返回值。旧值——比如在后置条件中需要引用输入的时候——可以通过 <code class=\"language-text\">old(...)</code> 来得到。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">AddOne</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token keyword\">value</span><span class=\"token punctuation\">)</span>\n    ensures <span class=\"token keyword\">return</span> <span class=\"token operator\">==</span> <span class=\"token function\">old</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">value</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当然，前置条件和后置条件可以一起混用。例如，在 Midori 内核中的环形缓冲区的实现里：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">bool</span></span> <span class=\"token function\">PublishPosition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token class-name\">requires</span> RemainingSize <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n    <span class=\"token class-name\">ensures</span> UnpublishedSize <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个方法的函数体在执行时可以确信 <code class=\"language-text\">RemainingSize</code> 一定为 <code class=\"language-text\">0</code>，调用者在调用之后也可以确信 <code class=\"language-text\">UnpublishedSize</code> 也一定为 <code class=\"language-text\">0</code>。</p>\n<p>在运行时，任何一个合约没有被满足时，都将会触发放弃。</p>\n<p>在这个领域，我们的方法跟其他人的工作有点不同。最近，合约在一些高级证明技术中的程序逻辑中作为一种表达式越来越流行，这些工具工厂使用全局分析来证明声明的的合约是否为真。我们也采用了类似的方法，但合约默认是在运行时检查的。如果编译器在编译期能够证明真假，那么它也可以不生成运行时检查的代码，或是抛出一个编译错误。</p>\n<p>现代的编译器都有基于约束的分析，在这方面做得很好，例如我上篇博客中提到的<a href=\"https://en.wikipedia.org/wiki/Value_range_analysis\">范围分析</a>。它们通过传递事实信息（facts）来对代码进行优化，例如消除冗余的检查：既包括显式声明的合约，也包括普通的程序逻辑。它们也能在合理的时间内完成这些分析，这样程序员才不会觉得太慢转而使用别的编译器。定理证明技术所支持的代码规模满足不了我们的需要。最好的定理证明分析框架花了整整一天来分析我们的核心系统模块！</p>\n<p>进一步来说，方法所声明的合约是它签名的一部分。这就意味着这些合约会自动显示在文档里、IDE 的代码提示里，等等。合约就跟方法的参数类型、返回类型一样重要。合约其实就是类型系统的扩展，使用语言所能表达的任何逻辑来对类型交换（exchange types）加以控制。因此，所有常见的对子类型的要求都适用于合约。同样，这也有助于模块化局部分析，使用标准优化的编译器技术能够在几秒钟之内完成。</p>\n<p>.NET 和 Java 中大约 90% 的异常都能够使用前置条件替代，包括所有的<code class=\"language-text\">ArgumentNullException</code>、<code class=\"language-text\">ArgumentOutOfRangeException</code> 以及相关的类型。更重要的是，我们不再需要手动检查之后再 <code class=\"language-text\">throw</code> 了。如今很多 C# 代码中四处可见这样的检查，仅在 .NET 的 CoreFX 仓库中就有上千个。例如，下面是 <code class=\"language-text\">System.IO.TextReader</code> 中的 <code class=\"language-text\">Read</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token comment\">/// &lt;summary></span>\n<span class=\"token comment\">/// ...</span>\n<span class=\"token comment\">/// &lt;/summary></span>\n<span class=\"token comment\">/// &lt;exception cref=\"ArgumentNullException\">Thrown if buffer is null.&lt;/exception></span>\n<span class=\"token comment\">/// &lt;exception cref=\"ArgumentOutOfRangeException\">Thrown if index is less than zero.&lt;/exception></span>\n<span class=\"token comment\">/// &lt;exception cref=\"ArgumentOutOfRangeException\">Thrown if count is less than zero.&lt;/exception></span>\n<span class=\"token comment\">/// &lt;exception cref=\"ArgumentException\">Thrown if index and count are outside of buffer's bounds.&lt;/exception></span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">virtual</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Read</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> buffer<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> count<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>buffer <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">ArgumentNullException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"buffer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">ArgumentOutOfRangeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"index\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">ArgumentOutOfRangeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"count\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">.</span>Length <span class=\"token operator\">-</span> index <span class=\"token operator\">&lt;</span> count<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">ArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样的写法不太好，原因有很多。显而易见的是它太冗长了，除此之外似乎没什么不好——然而，我们需要在文档中提及所有可能抛出异常，这似乎在提醒开发人员，这些异常需要被捕获。但这些异常真的不应该被捕获，相反，它们应该在开发阶段就发现这些 bug 然后修掉。</p>\n<p>另一方面，如果我们使用 Midori 风格的合约，则这些代码可以简化为：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token comment\">/// &lt;summary></span>\n<span class=\"token comment\">/// ...</span>\n<span class=\"token comment\">/// &lt;/summary></span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">virtual</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Read</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> buffer<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> count<span class=\"token punctuation\">)</span>\n    requires buffer <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span>\n    requires index <span class=\"token operator\">>=</span> <span class=\"token number\">0</span>\n    requires count <span class=\"token operator\">>=</span> <span class=\"token number\">0</span>\n    requires buffer<span class=\"token punctuation\">.</span>Length <span class=\"token operator\">-</span> index <span class=\"token operator\">>=</span> count <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码有很多地方值得一说。首先，它更简洁，更重要的是，它以一种文档化的方式描述了这个 API 的合约，调用者也更容易理解。相比于使用用于来描述这些错误条件，调用者还可以直接查看表达式，相关工具也更容易理解和利用这些条件。最后，当合约检查失败时，它会触发放弃。</p>\n<p>同样值得一说的是，我们提供了非常多的合约帮助方法，以便能够更方便地实现一些常见的前置条件。上述的显式范围检查同样非常啰嗦，容易出错。我们可以改写为：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">virtual</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Read</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> buffer<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> count<span class=\"token punctuation\">)</span>\n    requires buffer <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token return-type class-name\">requires</span> Range<span class=\"token punctuation\">.</span><span class=\"token function\">IsValid</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">,</span> buffer<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>说句有点偏题的，如果结合两个高级功能——数组切片和非空类型——我们能够进一步简化代码，同时提供了相同的承诺：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">virtual</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Read</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> buffer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>还是让我们从头开始讲吧…</p>\n<h2 id=\"谦卑的开始\" style=\"position:relative;\"><a href=\"#%E8%B0%A6%E5%8D%91%E7%9A%84%E5%BC%80%E5%A7%8B\" aria-label=\"谦卑的开始 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>谦卑的开始</h2>\n<p>虽然我们最终的语法很像 Eiffel 和 Spec#，但就像我前面提到的，我们一开始并没有想改变语言本身。因此我们从 API 开始：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">bool</span></span> <span class=\"token function\">PublishPosition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Contract<span class=\"token punctuation\">.</span><span class=\"token function\">Requires</span><span class=\"token punctuation\">(</span>RemainingSize <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Contract<span class=\"token punctuation\">.</span><span class=\"token function\">Ensures</span><span class=\"token punctuation\">(</span>UnpublishedSize <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这种方法有很多问题，就像 <a href=\"https://research.microsoft.com/en-us/projects/contracts/\">.NET Code Contracts</a> 所遇到的一样。</p>\n<p>首先，这种方式实现的合约属于 API <em>实现</em> 的一部分，然而我们希望它成为 API <em>签名</em> 的一部分。这似乎只是理论上的问题，但其实不是。我们希望生成的程序包含一些内置的元数据，从而像 IDE、调试器之类的工具能够在函数调用时把合约显示出来。我们也希望文档工具能够根据合约自动生成文档。把合约埋在实现当中无法实现这些功能，除非你知道如何反汇编这些函数然后再把这些信息提取出来（然而这是一种hack）。这也让合约与编译器后端的整合更加困难，生成高性能的代码需要这些信息。</p>\n<p>其次，你可能会注意到对 <code class=\"language-text\">Contract.Ensures</code> 的调用。<code class=\"language-text\">Ensures</code> 需要在函数的每一个返回点调用，我们如何只使用 API 来实现呢？答案是：确实不能。一种方法是在编译器生成 MSIL 后，对 MSIL 进行重写，但这很麻烦。看到这你也许回想，为什么我们不能简单地承认这是一个语言的表达能力和予以的问题，然后加上专门的语法呢？</p>\n<p>另一方面，一个长期举棋不定的问题是合约是否允许根据编译模式的不同而不同。很多经典的系统中，Debug 模式会检查合约，但完全优化的版本不会。在很长一段时间里，我们有三种不同级别的合约，就像我们之前提到的断言一样：</p>\n<ul>\n<li>Weak，声明为 <code class=\"language-text\">Contract.Weak.*</code>，表示仅在 Debug 模式开启</li>\n<li>Normal，声明为 <code class=\"language-text\">Contract.*</code>，表示由具体实现来决定什么时候检查合约</li>\n<li>Strong，声明为 <code class=\"language-text\">Contract.Strong.*</code>，表示始终检查。</li>\n</ul>\n<p>我得承认，一开始我觉得这种方案非常优雅。然而不幸的是，始终都有人对“Normal”合约存在疑惑，它们会在 Debug 还是 Release 模式下开启？开始两者都会开启？（也因此大家也都用错了 Weak 和 Strong。）不管怎样，我们开始把这种合约模式整合进语言，以及编译器后端工具链。而此时，问题开始不断出现。我们不得不做出一些妥协。</p>\n<p>首先就是，如果你简单的把 <code class=\"language-text\">Contract.Weak.Requires</code> 翻译为 <code class=\"language-text\">weak requires</code>、把 <code class=\"language-text\">Contract.Strong.Requires</code> 翻译为 <code class=\"language-text\">strong requires</code>，你会的到一种相当笨拙而又不够普适的语法，过多可选的策略也让我不舒服。这就直接引出了 <code class=\"language-text\">weak/strong</code> 策略的参数化和可替换性。</p>\n<p>其次，这种方法引入了一种新的条件编译模式，对我而言有点不爽。换句话说，如果你想要只在 Debug 模式下检查，已经有语法来实现了：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token preprocessor property\">#<span class=\"token directive keyword\">if</span> DEBUG</span>\n    requires X\n<span class=\"token preprocessor property\">#<span class=\"token directive keyword\">endif</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>最后——对我而言这是压死骆驼的最后一根稻草——合约应该是 API 签名的一部分。条件编译一个合约是几个意思？相关工具应该怎么看待 API 签名？需要为 Debug 和 Release 模式产生不同的文档吗？更进一步，如果我们真的采取了这种方式，你就失去了严格的保证——即如果前置条件不满足，你的代码就不会运行。</p>\n<p>最后，我们修改了整个条件编译的方案。</p>\n<p>我们最终只采用了一种合约：它是 API 签名的一部分，并且始终检查。如果一个编译器在编译阶段就能够证明合约成立（我们花了很大的精力在这个方面），那么可以省略这些检查。我们始终都能够保证前置条件不满足的话就不执行代码。任何需要条件检查的情况，都可以使用上面提到的断言系统。</p>\n<p>在部署了这个新的模型之后，我跟高兴曾经误用了“weak”和“strong”的人都不再困惑了。强迫开发人员做出决定，有助于提高代码的质量。</p>\n<h2 id=\"未来的方向\" style=\"position:relative;\"><a href=\"#%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%96%B9%E5%90%91\" aria-label=\"未来的方向 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>未来的方向</h2>\n<p>当我们的项目结束的时候，很多领域都已经不同程度地有所成熟。</p>\n<h3 id=\"不变量invariants\" style=\"position:relative;\"><a href=\"#%E4%B8%8D%E5%8F%98%E9%87%8Finvariants\" aria-label=\"不变量invariants permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>不变量（Invariants）</h3>\n<p>我们对不变量做了大量的尝试。每次我跟精通合约设计的人讨论问题的时候，他们对我们没有从一开始就使用不变量感到惊讶。老师说，我们的设计的确一开始就包括了这些内容，但我们没能有足够的时间来实现和部署这一功能。部分原因是工程人力的不足，但同时也是由于存在一些难以解决的问题。同时，团队几乎对前置条件、后置条件和断言非常满意。我甚至怀疑，随着时间的推移，我们已经完整实现了不变量，但如今仍有一些问题困扰着我。我得再多看一看它在实践中的应用。</p>\n<p>我们的设计所提供的方法是，<code class=\"language-text\">invaraint</code> 是类型内部的一个成员。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">List<span class=\"token punctuation\">&lt;</span>T<span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> array<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> invariant index <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> index <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">;</span>\n<span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>需要注意的是 <code class=\"language-text\">invariant</code> 标记为了 <code class=\"language-text\">private</code>。一个不变量的访问控制符表明了这个不变量需要检查的成员。例如，一个 <code class=\"language-text\">public invaraint</code> 只需要对 <code class=\"language-text\">public</code> 函数的入口和出口做出限制。这使得一些 <code class=\"language-text\">private</code> 函数能够临时的破坏不变量，只要其在 <code class=\"language-text\">public</code> 的入口和出口处仍然成立即可，这也是一种常见的模式。当然，就像上面的例子一样，一个类也可以声明一个 <code class=\"language-text\">private invariant</code>，这就要求所有的函数在进入和退出时都要满足不变量的条件。</p>\n<p>我非常喜欢这种设计，我也认为它能够实现。一个主要的忧虑是我们在所有的地方都引入了一个隐式的检查。就算在今天，这也让我有点不安。例如在 <code class=\"language-text\">List&lt;T></code> 的例子中，这个类中的每一个函数的开始和结束的地方都需要插入 <code class=\"language-text\">index >= 0 &amp;&amp; index &lt; array.Length</code> 的检查。我们的编译器最终能够很好的识别并合并冗余的合约检查，并且在很多情况下合约都能够 <em>显著</em> 提高代码的质量。然而，在上面给出的极端例子中，我确信性能上会有所影响。这迫使我们考虑换一种不变量的检查策略，而这可能会使得整个合约模型变得复杂。</p>\n<p>我真的希望我们能够有更多的时间，来更深入地探索不变量。我们的团队似乎并没有对这个功能非常期待——至少我们没有听到过抱怨没有不变量的声音（也许是因为整个团队特别看重性能问题）——但我确定的是，不变量肯定会为合约系统增色不少。</p>\n<h3 id=\"高级类型系统\" style=\"position:relative;\"><a href=\"#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F\" aria-label=\"高级类型系统 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>高级类型系统</h3>\n<p>我喜欢这种说法：合约是类型系统的补充。类型系统让你能够使用类型来对变量的属性进行定义，例如类型可以限制一个变量的值的范围。合约同样可以检查变量的值的范围。那么区别在哪呢？在编译时，严格的、可组合的归纳规则确保了类型的正确性。在检查局部的函数时，这些规则通常不会太耗时，同时还会有开发人员提供的标注作为帮助（不过也可能没有）。而合约则是：尽可能的在编译期证明合约的正确性，如果证明不了的话，就在运行时检查。因此，合约不提供严格的规范，允许使用语言本身提供的任意逻辑进行声明。</p>\n<p>类型总是首选，因为它们能够在编译期就提供保证，而且保证能够做到快速地检查。这种为开发人员提供的强有力的保证，有助于提高开发人员整体的生产力。</p>\n<p>然而，类型系统不可避免地有一些限制；类型系统需要留出一定的回旋的余地，否则它们就会变得非常难用。极端的情况下，类型系统甚至会退化至位/字节级别的规定。即便如此，有两点“回旋的余地”始终让我很不爽，使得我们必须使用合约来解决：</p>\n<ol>\n<li>是否可为空</li>\n<li>数值范围</li>\n</ol>\n<p>大约 90% 的合约会落入这两点当中。结果就是，我们认真探索了更加复杂的类型系统，以便能够使用类型系统（而不是合约）来判别是否为空、以及变量值的范围。</p>\n<p>具体来说，下面这段代码使用了合约：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">virtual</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Read</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> buffer<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> count<span class=\"token punctuation\">)</span>\n    requires buffer <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span>\n    requires index <span class=\"token operator\">>=</span> <span class=\"token number\">0</span>\n    requires count <span class=\"token operator\">>=</span> <span class=\"token number\">0</span>\n    requires buffer<span class=\"token punctuation\">.</span>Length <span class=\"token operator\">-</span> index <span class=\"token operator\">&lt;</span> count <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>而下面这段代码则不需要，只利用编译期的静态检查就能够得到同样的保证：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">virtual</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Read</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> buffer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>将这些属性放入类型系统能够大幅度减轻错误检查的负担。举个例子，对于某个状态来说，它有 1 个生产者、10 个消费者。与其在 10 个消费者那里对状态进行检查，我们可以做到把检查放到生产者那里——比如加上一句强制的类型断言，或者更好的做法是一开始就把值存进正确的类型中。</p>\n<h3 id=\"非空类型\" style=\"position:relative;\"><a href=\"#%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B\" aria-label=\"非空类型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>非空类型</h3>\n<p>第一点其实有点难办：静态地保证一个变量不会为 <code class=\"language-text\">null</code> 值。这就是 Tony Hoare （译注：就是上文提到的 C. Hoare）所说的著名的“<a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\">billion dollar mistake</a>”。对任何语言来说，想办法解决这个问题都是一个非常合理的目标。现在很多新语言的设计师都决定直面这个问题，我非常高兴。</p>\n<p>一门语言的很多方面都会阻碍我们实现这一特性，泛型、零值初始化、构造函数，等等。把非空类型添加进一门现有的语言真的很难！</p>\n<h4 id=\"类型系统\" style=\"position:relative;\"><a href=\"#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F\" aria-label=\"类型系统 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>类型系统</h4>\n<p>简单来说，非空类型可以简单归纳为类型系统的一些规则：</p>\n<ol>\n<li>所有不加装饰的类型 <code class=\"language-text\">T</code> 默认都是非空的</li>\n<li>所有添加了 <code class=\"language-text\">?</code> 的类型，例如 <code class=\"language-text\">T?</code>，都是可空的</li>\n<li>对于非空类型来说，<code class=\"language-text\">null</code> 是不合法的值</li>\n<li><code class=\"language-text\">T</code> 能够隐式转换为 <code class=\"language-text\">T?</code>。换句话说，<code class=\"language-text\">T</code> 是 <code class=\"language-text\">T?</code> 的一个子类型（尽管不完全对）</li>\n<li>存在从 <code class=\"language-text\">T?</code> 到 <code class=\"language-text\">T</code> 的显式转换，运行时需要检查是否为空，如果为空则触发放弃</li>\n</ol>\n<p>这其中的大部分似乎都“显而易见”，我们没有太多的选择。根据类型名称的不同，类型系统能够知道 <code class=\"language-text\">null</code> 的所有路径。具体来说，一个 <code class=\"language-text\">null</code> 永远不能偷偷地变成一个非空类型 <code class=\"language-text\">T</code>；这就意味着我们需要零值初始化，也许这才是所有问题当中最难的一个。</p>\n<h4 id=\"语法\" style=\"position:relative;\"><a href=\"#%E8%AF%AD%E6%B3%95\" aria-label=\"语法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>语法</h4>\n<p>我们提供了几种将 <code class=\"language-text\">T?</code> 转换为 <code class=\"language-text\">T</code> 的语法，用来实现第 5 条规则。当然，我们不建议做这种转换，而是更希望你能够尽可能地使用非空的类型。但有时候确实是需要做转换的。多阶段初始化很常见，尤其是容器类的数据结构，因此还是需要支持这种转换。</p>\n<p>考虑一下，假如我们有一个 map：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\">Map<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> Customer<span class=\"token punctuation\">></span></span> customers <span class=\"token operator\">=</span> <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>这一句构造语句告诉我们：</p>\n<ol>\n<li>Map 自身不为 <code class=\"language-text\">null</code></li>\n<li>Map 当中的 <code class=\"language-text\">int</code> 键不会为 <code class=\"language-text\">null</code></li>\n<li>Map 当中的 <code class=\"language-text\">Customer</code> 值也不会为 <code class=\"language-text\">null</code></li>\n</ol>\n<p>假设我们在索引函数中，使用 <code class=\"language-text\">null</code> 来表示某个键不存在的情况：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token return-type class-name\">TValue<span class=\"token punctuation\">?</span></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">TKey</span> key<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">get</span> <span class=\"token punctuation\">{</span> <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>那么现在我们需要在调用处检查一下索引是否成功。我们讨论了很多种语法。</p>\n<p>最简单的方法是加上一个检查来做保护：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\">Customer<span class=\"token punctuation\">?</span></span> customer <span class=\"token operator\">=</span> customers<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>customer <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 此处的 `customer` 变为非空类型 `Customer`</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我承认，我总是对神奇的隐式转换持怀疑态度。当出现问题的时候，很难发现到底是哪里不对。例如，当你试图将 <code class=\"language-text\">c</code>（译注：应为 <code class=\"language-text\">customer</code>）跟一个值为 <code class=\"language-text\">null</code> 的变量进行比较的时候，就会出现问题。不过，这种语法很好记，而且通常情况下都没问题。</p>\n<p>当值确实为 <code class=\"language-text\">null</code> 时，这种语法就会执行另一条分支。但有时你只是像简单地做一次断言，如果值为空则触发放弃。显式类型断言操作符能够实现这样的操作：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\">Customer<span class=\"token punctuation\">?</span></span> maybeCustomer <span class=\"token operator\">=</span> customers<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Customer</span> customer <span class=\"token operator\">=</span> <span class=\"token keyword\">notnull</span><span class=\"token punctuation\">(</span>maybeCustomer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">notnull</code> 操作符将任意的 <code class=\"language-text\">T?</code> 类型的表达式转换为 <code class=\"language-text\">T</code> 类型。</p>\n<h4 id=\"泛型\" style=\"position:relative;\"><a href=\"#%E6%B3%9B%E5%9E%8B\" aria-label=\"泛型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>泛型</h4>\n<p>泛型有点复杂，因为有多级的可空性需要考虑。考虑下面的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\">T</span> <span class=\"token generic-method\"><span class=\"token function\">M</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>T<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\">T<span class=\"token punctuation\">?</span></span> <span class=\"token generic-method\"><span class=\"token function\">N</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>T<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> a <span class=\"token operator\">=</span> C<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">M</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">object</span><span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> b <span class=\"token operator\">=</span> C<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">M</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">object</span><span class=\"token punctuation\">?</span><span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> c <span class=\"token operator\">=</span> C<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">N</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">object</span><span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> d <span class=\"token operator\">=</span> C<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">N</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">object</span><span class=\"token punctuation\">?</span><span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>一个很基本的问题是：<code class=\"language-text\">a</code>、<code class=\"language-text\">b</code>、<code class=\"language-text\">c</code> 和 <code class=\"language-text\">d</code> 的类型是什么？</p>\n<p>一开始我们走了点弯路，主要是因为我们当时在模仿 C# 中的 <code class=\"language-text\">nullable</code>，但其实 C# 的 <code class=\"language-text\">nullable</code> 有点特别。好消息是，我们最终找到了自己的方法，虽然花了点时间。举个例子来说明我想表达的意思，关于这个问题的答案，现在有两大阵营：</p>\n<ul>\n<li>.NET 阵营：<code class=\"language-text\">a</code> 是 <code class=\"language-text\">object</code>；<code class=\"language-text\">b</code>、<code class=\"language-text\">c</code> 和 <code class=\"language-text\">d</code> 是 <code class=\"language-text\">object?</code></li>\n<li>函数式语言阵营：<code class=\"language-text\">a</code> 是 <code class=\"language-text\">object</code>；<code class=\"language-text\">b</code> 和 <code class=\"language-text\">c</code> 是 <code class=\"language-text\">object?</code>；<code class=\"language-text\">d</code> 是 <code class=\"language-text\">object??</code></li>\n</ul>\n<p>换句话说，.NET 阵营认为你应该把所有的 <code class=\"language-text\">?</code> 压缩成一个。而理解了数学组合之美的函数式阵营，则选择不使用任何神奇的操作，让这个世界该怎么样就怎么样。我们最终意识到，.NET 的方法出奇的复杂，同时还需要运行时支持。</p>\n<p>函数式语言的方法确实会让人一时摸不着头脑。例如，前面举的 map 的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\">Map<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> Customer<span class=\"token punctuation\">?</span><span class=\"token punctuation\">></span></span> customers <span class=\"token operator\">=</span> <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\nCustomer<span class=\"token operator\">??</span> customer <span class=\"token operator\">=</span> customers<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>customer <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 请注意, `customer` 在此处为 `Customer?`，仍然可能为 `null`！</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个模型中，每次只能剥掉一次 <code class=\"language-text\">?</code>。但说实话，如果停下来想想，就会发现这其实很有道理。它更加透明，准确地表达了究竟发生了什么事。我们最好不要逆势而为。</p>\n<p>此外，在实现上还有问题需要考虑。最简单的实现方法是把 <code class=\"language-text\">T?</code> 扩展为某些“wrapper”类型，比如<code class=\"language-text\">Maybe&lt;T></code>，然后插入合适的 <code class=\"language-text\">wrap</code> 和 <code class=\"language-text\">unwrap</code> 操作。确实，这似乎是一个合理的实现方法。但有这个模型存在两点问题。</p>\n<p>第一点问题是，对于引用类型 <code class=\"language-text\">T</code> 来说，<code class=\"language-text\">T?</code> 不能浪费不必要的空间——一个指针的运行时表示已经能够包括 <code class=\"language-text\">null</code> 了。作为一门系统语言，我们希望能把 <code class=\"language-text\">T?</code> 和 <code class=\"language-text\">T</code> 实现得一样高效。这可以简单地通过特化泛型的实例化来解决。但这意味着非空类型不再只是简单的前端问题，变为需要编译器后端支持。（需要注意的是，这种解决方案难以扩展至 <code class=\"language-text\">T??</code>）</p>\n<p>第二点是， 由于有可变型（Mutability）的标注，Midori 支持安全协变（safe covariant）数组。如果 <code class=\"language-text\">T和T?</code> 有着不同的物理表示，那么从 <code class=\"language-text\">T[]</code> 到 <code class=\"language-text\">T?[]</code> 就不是一种转换操作了。这其实只是个小瑕疵，特别是当你堵住了协变数组的安全漏洞之后，协变数组就不再那么有用了。</p>\n<p>不管怎样，我们最后放弃了 .NET <code class=\"language-text\">Nullable&lt;T></code> 这条路，转而使用了组合性更强的多个 <code class=\"language-text\">?</code> 的设计。</p>\n<h4 id=\"零值初始化\" style=\"position:relative;\"><a href=\"#%E9%9B%B6%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96\" aria-label=\"零值初始化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>零值初始化</h4>\n<p>零值初始化是一个真正的难题。它需要：</p>\n<ul>\n<li>一个类的所有非空域（field）都需要在构造时初始化</li>\n<li>一个非空类型的数组中的所有成员需要在构造时全部初始化</li>\n</ul>\n<p>但这还不是最糟糕的。在 .NET 中，所有的值类型（value types）都是隐式零值初始化的。因此最基本的规则就是:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">一个 struct 的所有域必须是可空的</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>绝望的气息。这几乎把整个系统都污染了。我的假设是，只有当可空类型不常用时（比如 20% 的使用率），不可空性才会真正有用。这条规则立刻就毁了一切。</p>\n<p>所以我们开始了去除自动零值初始化的工作，工作量非常大。（C# 6 则选择了允许 struct 提供自己的零值初始化构造函数，<a href=\"https://github.com/dotnet/roslyn/issues/1029\">但由于对整个生态系统的影响太大而不得不放弃</a>。）非空类型本来是能够成功的，但我们有点偏离了跑道、分了心，进而引出了别的问题。如果我能再重来一次，我只需要将 C# 中的值类型和引用类型统一起来就够了。在我下一篇文章——垃圾回收的斗争之路中，这方面的原因将会有更清楚的解释。</p>\n<h4 id=\"非空类型的命运\" style=\"position:relative;\"><a href=\"#%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%91%BD%E8%BF%90\" aria-label=\"非空类型的命运 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>非空类型的命运</h4>\n<p>我们有坚实的设计、实现了几个原型，但从来没有在整个操作系统层面部署这个功能。原因与我们所期望的 C# 兼容性有关。公平地说，我在这件事上犹豫了很久，最终就做出了这样的决定。在 Midori 的早期，我们希望人们一见到它就觉得很熟悉；后来，我们甚至在考虑，是不是所有的功能都能够作为 C# 的附加扩展来实现。正是这种想法阻碍了非空类型的实现。如今我相信，仅仅添加一些标注是无法成功的——Spec# 已经这么尝试过了！而且空和非空的默认选择应该倒过来——非空值必须得是默认实现，它才能够达到我们想要的效果。</p>\n<p>我最大的遗憾之一就是没能尽早着手非空类型的工作。我们在开始大规模应用合约之后才开始非空类型的探索——因为我们发现代码中充斥着成千上万个 <code class=\"language-text\">requires x != null</code>。虽然它很复杂、代价很高，但如果同时把去除值类型也实现的话，它们俩绝对是个超赞的组合。真的是要活到老学到老啊！</p>\n<p>如果我们把我们的语言从 C# 独立出来单独发布，我相信我们能做的更好。</p>\n<h3 id=\"范围类型\" style=\"position:relative;\"><a href=\"#%E8%8C%83%E5%9B%B4%E7%B1%BB%E5%9E%8B\" aria-label=\"范围类型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>范围类型</h3>\n<p>我们设计过向 C# 中添加范围类型，但它的复杂度总是刚好高过我能接受的程度。</p>\n<p>基本的想法是，每一个数值类型都可以接受一个下界类型参数和一个上界类型参数。例如，你能够表达出一个整型只能存放 0 到 1000000 之间的整数。例如声明为 <code class=\"language-text\">int&lt;0..1000000></code>。当然，这其实代表你应该使用一个 <code class=\"language-text\">uint</code>，编译器应该能够给出警告。实际上，所有的整型都可以根据这个概念进行表示：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> byte number<span class=\"token operator\">&lt;</span><span class=\"token number\">0.</span><span class=\"token number\">.256</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> sbyte number<span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span><span class=\"token number\">128.</span><span class=\"token number\">.128</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">short</span> number<span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span><span class=\"token number\">32768.</span><span class=\"token number\">.32768</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> ushort number<span class=\"token operator\">&lt;</span><span class=\"token number\">0.</span><span class=\"token number\">.65536</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> number<span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span><span class=\"token number\">2147483648.</span><span class=\"token number\">.2147483648</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> uint number<span class=\"token operator\">&lt;</span><span class=\"token number\">0.</span><span class=\"token number\">.4294967295</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>真正帅爆了（但同时极度复杂）的是，我们可以进而使用依赖类型来允许符号范围参数。例如，我有一个数组，并且希望传入的索引能够保证在某个范围之内。通常来说我会写：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\">T</span> <span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> index<span class=\"token punctuation\">)</span>\n        requires index <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> index <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">.</span>Length <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>或者我可以使用 <code class=\"language-text\">uint</code> 来替代前半部分的检查：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\">T</span> <span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">uint</span></span> index<span class=\"token punctuation\">)</span>\n        index <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">.</span>Length <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果有了范围类型，我就可以把索引的上界跟数组的长度直接绑定起来：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\">T</span> <span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\">number<span class=\"token punctuation\">&lt;</span>0<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">></span></span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>当然，如果你破坏了编译器的别名检查，边界检查可能就会在运行时进行了。但我们希望至少它能跟合约检查的代价相当。必须要承认，这种方法就是对类型系统中的信息进行更直接的操作。</p>\n<p>不管怎样，我还是觉得这个主意太酷了。不过它仍然是“有它更好，没有也不强求”的那一类功能。“不强求”的原因在于，在我们的类型系统中，切片（slice）是一等公民。我打赌，在三分之二甚至更多的情况下，切片是比范围检查更合适的写法。我认为大多数人还是习惯于使用范围检查，因此他们还是写出了标准的 C# 写法，而不是使用切片。我会在之后的文章中介绍切片，在大多数情况下，它确实能够替代范围检查。</p>"},"childMdx":null}},{"node":{"id":"cab2b1e3-0879-5e11-8c7a-95b972d3166b","relativePath":"the-error-model/5-ecoverable-errors-type-directed-exceptions.md","childMarkdownRemark":{"fields":{"slug":"/the-error-model/5-ecoverable-errors-type-directed-exceptions/"},"frontmatter":{"title":"五、可恢复错误：类型导向的异常"},"html":"<p>我们当然不是只需要“放弃”就够了。在很多情况i西安，程序员能够把程序从发生的错误中恢复过来。例如：</p>\n<ul>\n<li>文件 I/O</li>\n<li>网络 I/O</li>\n<li>解析数据（例如编译器的语法分析器）</li>\n<li>验证用户数据（例如用户提交的网页表单）</li>\n</ul>\n<p>在这些情况下，遇到错误时你通常不会想要触发放弃。相反，你的程序应该做好了随时遇见这些错误的准备，并且能够合理地解决它们。通常来说是向某些人传递一些信息：例如在网页上输入数据的用户、系统的管理员、开发人员等等。当然，如果合适的话，放弃仍然可以作为一种选择，但通常来说这有点太夸张了。尤其是对于 IO 操作来说，这会让整个系统太过脆弱。想象一下：每当你的网络丢了一个包时，你的程序就决定从此消失！</p>\n<h2 id=\"使用异常\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8\" aria-label=\"使用异常 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用异常</h2>\n<p>我们使用异常来应对可恢复错误。不是不受检查的那种，跟 Java 的受检查异常也不太一样。</p>\n<p>必须要说明的是：虽然 Midori 使用异常，但一个没有标记为 <code class=\"language-text\">throws</code> 的方法永远不允许抛出异常。 Java 中提供的鬼鬼祟祟的 <code class=\"language-text\">RuntimeException</code> 在这是不存在的。我们其实也不需要它，因为在 Java 中使用 <code class=\"language-text\">RuntimeException</code> 的那些情况，在 Midori 中会使用放弃来进行处理。</p>\n<p>在最终的系统中，我们神奇的发现，大约有 90% 的函数不会抛出异常！或者说，它们根本不允许抛出异常。这与 C++ 之类的系统形成了鲜明对比——在那些系统中，你必须时刻尽力地避免碰上异常，还需要使用 <code class=\"language-text\">noexcept</code> 来标记。由于存在放弃机制，API 调用仍然可能会失败，但只有调用者没有满足声明的合约时在会发生——类似于传入的参数类型错误。</p>\n<p>我们选择使用异常，但这从一开始就有争议。命令式、过程式、面向对象和函数式语言的方法，在我们组里全都有人支持。C 程序员想要用错误码，担心我们会重新发明 Java 的异常设计，甚至更糟糕—— C# 的设计。函数式的观点认为我们应该使用数据流来应对所有错误，异常是一种面向控制流的方法。最后，我认为我们选择的是一种集所有优点于一身的组合模型。一会我们就会看到，我们的确提供了一种机制来将错误看作是一等公民，并且正如开发人员想要的一样，使用数据流风格的编程方法来处理这些偶发情况。</p>\n<p>最重要的是，我们使用这种模型写了一堆的代码，对我们来说这个模型工作的很好，甚至得到了经常使用函数式语言的朋友的认可。由于我们也从返回码模型中汲取了一些经验，这让 C 程序员们也很开心。</p>\n<h2 id=\"语言和类型系统\" style=\"position:relative;\"><a href=\"#%E8%AF%AD%E8%A8%80%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F\" aria-label=\"语言和类型系统 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>语言和类型系统</h2>\n<p>当时，我做了一个有争议的决定。正如当我们改变了函数的返回类型时，一定会产生兼容性的影响，你也不应该认为改变了函数的异常类型时就没什么兼容性影响。换句话说，<em>异常和错误码一样，都是返回值的一种！</em></p>\n<p>这一点在之前介绍受检查的异常时提到过，它是受检查异常的反对者的论据之一。我的回答有点老套，但很简单：反对得不对。你正在使用的是一门静态类型编程语言，而异常的动态特性才是它们难用的原因。我们想要去解决这些问题，因此我们接受了“异常是一种返回值”的观点，并辅之以强类型。我们从没想过要回头。错误码和异常之间就这样建立起了一座桥梁。</p>\n<p>一个函数所抛出的异常是它的签名的一部分，就像参数和返回值一样。请记住，由于异常本来就很少见，这种做法没有你想象的那么痛苦。进而，很多直观的想法就自然而然地出现了。</p>\n<p>首先要说的是<a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\">里斯科夫替换原则（Liskov Substitutin Priciple）</a>。为了避免类似于 C++ 的糟糕局面，所有“检查”都在编译期发生。因此，在 <a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3051.html\">WG21</a> 中所提到的所有性能问题，对我们来说就都不是问题了。类型系统必须坚不可摧，禁止存在任何后门。之所以类型安全与这个问题息息相关，是因为我们的优化器需要依赖于 <code class=\"language-text\">throws</code> 标注才能解决这些性能问题。</p>\n<p>我们尝试过使用不同的语法。在我们对语言进行修改之前，我们已经尝试过了各种使用 C# 属性（attribute）和静态分析的方法。用户体验不是非常好，也难以做出一个真正的类型系统。这种方法也存在太多的限制。我们曾经尝试过 Redhawk 项目所采取的方法——Redhawk 最终变为了 .NET Native 和 CoreRT——然而，他们的方法同样没有借助语言本身，而是使用了静态分析。不过他们跟我们的最终方案还是有着很多相似之处的。</p>\n<p>最终的语法大概是这样，一个方法后面只跟着一个 <code class=\"language-text\">throw</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> throws <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>（有很长一段时间，我们把 <code class=\"language-text\">throws</code> 放在了函数的最前面。但那种方式读起来有问题。）</p>\n<p>这时，可替代性的问题就非常简单了。一个 <code class=\"language-text\">throws</code> 函数不能够替换一个非 <code class=\"language-text\">throws</code> 函数（不合法的加强）。另一方面，非 <code class=\"language-text\">throws</code> 函数能够替换 <code class=\"language-text\">throws</code> 函数（合法减弱）。显然，虚重载、接口实现和 Lambda 会受到这些规则的影响。</p>\n<p>我们也实现了预想的协变、反协变替换。例如，如果 <code class=\"language-text\">Foo</code> 是个虚方法，而你的重载实现不会抛出异常，那么你就不需要声明 <code class=\"language-text\">throws</code>。当然， 只有直接调用它时，非 <code class=\"language-text\">throw</code> 的性质才会体现，通过虚方法调用它的话则不会。</p>\n<p>例如，这是合法的：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">virtual</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> throws <span class=\"token punctuation\">{</span><span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 某个特定的实现可能不会抛出异常</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">override</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在直接调用 Drived 的方法时，可以从非 <code class=\"language-text\">throws</code> 这一点获益。然而，下面的写法完全不合法：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">virtual</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> Foo <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Derived</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">Base</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">override</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> throws <span class=\"token punctuation\">{</span><span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>鼓励使用“单一失败模式”解放了我们——Java 的受检查异常所带来的大量的复杂性瞬间就消失了。如果你看一下 Midori 中可能会失败的 API，大多数都采取了单一失败模式（曾经所有的失败模式都是利用放弃完成的），不论是 IO 失败还是解析失败，等等。例如在处理 IO 操作时，开发人员所准备的恢复操作大多与 <em>究竟发生了什么错误无关</em>。（有一些是有关的，而对于那些情况，看守人模式（the keeper pattern）则更加适合。下面很快会讨论到这一点。）其实大多数现代的异常中所携带的信息，从编程角度来说，都没什么用；相反，它们是为了更方便的调试和查错。</p>\n<p>大约有两到三年，我们都始终坚持这种“单一错误模式”。最终我又做了一个有争议的决定来支持多失败模式。这种情况不算常见，但经常从团队成员那里听到关于这一点的合理需求，使用的场景看起来很确实是合法的、有用的。这的确会增加类型系统的复杂度，但是跟处理其他的子类型差不多。更复杂的场景——例如终止（Abort）（下面会讨论）——需要我们提供这个功能。</p>\n<p>语法看起来像这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">throws</span> FooException<span class=\"token punctuation\">,</span> BarException <span class=\"token punctuation\">{</span>\n    <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>或者说，单一的 <code class=\"language-text\">throws</code> 是 <code class=\"language-text\">throws Exception</code> 的简写。</p>\n<p>如果你不关心，把这些显式错误类型“忘掉”也很简单。例如，也许你想把 <code class=\"language-text\">Foo</code> 包进一个 Lambda，但又不想让用户关心 <code class=\"language-text\">FooException</code> 和 <code class=\"language-text\">BarException</code>，那么就可以只写一个 <code class=\"language-text\">throws</code>。这似乎是一个很常见的模式：在系统内部，对于内部的控制流和错误处理来说，使用这种带类型的异常；而在 API 边界处，如果不需要具体的信息，就可以把这些异常都变为简单的 <code class=\"language-text\">throws</code>。</p>\n<p>所有的这些标注做法给可恢复错误带来了强大的能力。不过，如果合约与异常之间的比例是 10:1 的话，抛出单一的 <code class=\"language-text\">throws</code> 异常的函数与多异常模式的函数之比就又是 10:1。</p>\n<p>到这里，你也许会想，这与 Java 的受检查异常究竟有什么不同？事实上，</p>\n<ol>\n<li>大部分的错误都使用了放弃来处理，因此大多数 API 根本不会抛出异常。</li>\n<li>我们更建议使用单一错误模式，它让整个系统变得更加简洁。更进一步，多模式和单一模式之间的转换同样非常简单。</li>\n</ol>\n<p>强大的类型系统关于弱化和强化的支持在这里同样有所帮助，我们还做了一些别的事情来填补返回码和异常之间的鸿沟，提升了代码的可维护性，等等…</p>\n<h2 id=\"易于审核的调用现场\" style=\"position:relative;\"><a href=\"#%E6%98%93%E4%BA%8E%E5%AE%A1%E6%A0%B8%E7%9A%84%E8%B0%83%E7%94%A8%E7%8E%B0%E5%9C%BA\" aria-label=\"易于审核的调用现场 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>易于审核的调用现场</h2>\n<p>目前，我们还没能实现错误码方案中完全显式的语法。函数的声明提到了它们可能会失败（ ），但调用这些函数的地方的控制流仍然是隐式的（ ）。</p>\n<p>我们的异常模型中，我始终非常喜欢的就是这一点——调用方需要写明try：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token keyword\">value</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>这将会调用函数 <code class=\"language-text\">Foo</code>，如果发生了错误的话就继续向上传播，否则就把返回值赋给 <code class=\"language-text\">value</code>。</p>\n<p>这有一个巨大的好处：程序中所有的控制流都是显式的。你可以把 <code class=\"language-text\">try</code> 看作是一种条件 <code class=\"language-text\">return</code>（或者是条件 <code class=\"language-text\">throw</code> 也行）。在做 Code Review 时，我简直爱死这个语法了！例如，想象一下你有一个很长的函数，里面有一些try，这些显式的标记能让我们很容易地注意到可能失败的地方，进而能够了解整个控制流。这就跟理解一个 <code class=\"language-text\">return</code> 语句一样简单：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> throws <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">blah</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> x <span class=\"token operator\">=</span> <span class=\"token function\">blah_blah</span><span class=\"token punctuation\">(</span><span class=\"token function\">blah</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> y <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">blah</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;-- 可能会失败哟！</span>\n    <span class=\"token function\">blahdiblahdiblahdiblahdi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">blahblahblahblah</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">try</span> <span class=\"token function\">blahblah</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;-- 另一处可能会失败的地方！</span>\n    <span class=\"token function\">and_so_on</span><span class=\"token punctuation\">(</span><span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果你的编辑器提供语法高亮，<code class=\"language-text\">try</code> 会被加粗、变成蓝色，这就更给力了。这种方案吸收了错误码的很多长处，同时又丢掉了所有的包袱。</p>\n<p>（Rust 和 Swift 都提供了类似的语法。我必须得承认，我真的很遗憾，几年前我们没能把这个系统公布与众。它们的实现有所不同，但这绝对是它们语法中非常吸引人的地方。）</p>\n<p>如果你在一个函数里使用了try来调用一个函数，那么将会发生两种可能的情况：</p>\n<ul>\n<li>异常继续向上层传播</li>\n<li><code class=\"language-text\">try/catch</code> 块处理了这个错误</li>\n</ul>\n<p>如果是第一种情况，你也必须把你的函数声明为 <code class=\"language-text\">throws</code>。不过，是否要把类型信息也向上传播则取决于你。</p>\n<p>如果是第二种情况，因为我们能够了解到所有的类型信息，所以如果你试图 catch 没有声明的异常，编译器就会给出错误来避免不可达的代码。这是另外一个与经典的异常系统所不一样的、有争议的地方。我始终对下面这一点耿耿于怀：<code class=\"language-text\">catch (FooException)</code> 本质上隐藏了动态类型测试。你会允许一个人调用一个类型为 <code class=\"language-text\">object</code> 的 API，然后自动地把返回值赋值给一个其他类型的变量吗？当然不能！异常这里也是一样。</p>\n<p>在异常处理这个方面，CLU 同样对我们有所影响。里斯科夫在 A History of CLU 中讨论了这个话题：</p>\n<blockquote>\n<p>CLU 对待未处理异常的机制有点不同寻常。大多数机制都把这些异常再次抛出：如果一个调用者没有处理被调用方的异常，那么就把这个异常再抛给上面的调用者。我们不同意使用这种方法，因为它跟我们的模块化程序构建相违背。我们希望知道一个函数的说明就能够去调用它，而不是需要知道它是如何实现的。如果一个异常被自动传播出去，那么一个过程就有可能会抛出它声明中没有指明的异常。</p>\n</blockquote>\n<p>虽然我们不鼓励大范围的 <code class=\"language-text\">try</code> 块，但在概念上它跟传播错误码是一样的。举个例子，想象一下再使用错误码的系统里，例如 Go，你可能会写：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-go line-numbers\"><code class=\"language-go\"><span class=\"token keyword\">if</span> err <span class=\"token operator\">:=</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> err\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>在我们的系统里，你可以这样写：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">try</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>但你可能会说，我们用的是异常啊！这完全不一样啊！当然，运行时的系统有所不同。但从语言的“语义”角度来说，它们是一样的。我们鼓励大家从错误码的角度来看待这种方法，而不是它们熟知和喜爱的异常。这看起来有点高效：那我们为什么不直接使用错误码呢？下面我会介绍它们为什么确实是一样的，并会向你解释我们的选择。</p>\n<h3 id=\"语法糖\" style=\"position:relative;\"><a href=\"#%E8%AF%AD%E6%B3%95%E7%B3%96\" aria-label=\"语法糖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>语法糖</h3>\n<p>我们为错误处理提供了一些语法糖。<code class=\"language-text\">try/catch</code> 块的构建有点啰嗦，同时我们还建议要尽可能细粒度地处理错误，这就让每次都写 <code class=\"language-text\">try/catch</code> 块显得更加啰嗦。如果你把异常看作是一种错误码的话， 它甚至还有点 <code class=\"language-text\">goto</code> 的味道。这使得我们提供了一种 <code class=\"language-text\">Result&lt;T></code> 的类型，简单说它里面要么存放的是 <code class=\"language-text\">T</code>，要么是一个 <code class=\"language-text\">Exception</code>。</p>\n<p>它在控制流和数据流的世界之间建立起了一座桥梁，对于某些场景来说后者更加自然。两者都有其用武之地，尽管大多数开发人员都对控制流的语法更加习惯。</p>\n<p>举个例子，假设你想要在向上抛出异常之前记录下所有的错误。尽管这是一种常见的模式，使用<code class=\"language-text\">try/catch</code> 块的控制流看起来太重了：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> v<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    v <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 其他操作...</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    rethrow<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 使用变量 `v`...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在“其他操作”那里，你可能会加上一些本不该放在try块中的语句。对比一下使用 <code class=\"language-text\">Result&lt;T></code> 的方法，这更有返回值的感觉，处理更加局部化：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\">Result<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">value</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">value</span><span class=\"token punctuation\">.</span>IsFailure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">value</span><span class=\"token punctuation\">.</span>Exception<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">value</span><span class=\"token punctuation\">.</span>Exception<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 使用 `value.Value`...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">try ... else</code> 结构还允许使用自己定义的值来替代 <code class=\"language-text\">catch</code>，也可以触发放弃：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> value1 <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\"><span class=\"token keyword\">int</span></span> value2 <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> Release<span class=\"token punctuation\">.</span><span class=\"token function\">Fail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>通过将T的成员映射至 <code class=\"language-text\">Result&lt;T></code>，我们还支持了 <code class=\"language-text\">NaN</code> 形式的数据流错误传播。例如，假如我们有两个 <code class=\"language-text\">Result&lt;int></code> 希望进行相加操作：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\">Result<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> x <span class=\"token operator\">=</span> <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Result<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> y <span class=\"token operator\">=</span> <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Result<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> z <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>请注意第三行，我们将两个 <code class=\"language-text\">Result&lt;int></code> 加了起来，正确地产生了第三个 <code class=\"language-text\">Result&lt;T></code>。这就是 <code class=\"language-text\">NaN</code> 风格的数据流传播，与 C# 中新的 <code class=\"language-text\">.?</code> 功能类似。</p>\n<p>这种方法是对异常、返回错误码和数据流错误传播的一种优雅的混合。</p>\n<h3 id=\"实现\" style=\"position:relative;\"><a href=\"#%E5%AE%9E%E7%8E%B0\" aria-label=\"实现 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现</h3>\n<p>我上面所描述的模型不一定非要用异常来实现。它足够抽象，使用异常或是返回码进行实现都很合理。这不是纸上谈兵——我们确实做过尝试。而我们选择使用异常而不是错误码来实现，是出于性能考虑。</p>\n<p>下面来说明一下返回码的实现是如何工作的。我们来做一些简单的转换：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\"><span class=\"token keyword\">int</span></span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> throws <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>p<span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>将变成：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\">Result<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>p<span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Result<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Result<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>以及这样的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> x <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>将变成：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> x<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Result<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">></span></span> tmp <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">.</span>Failed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> tmp<span class=\"token punctuation\">.</span>Exception<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nx <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">.</span>Value<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>编译器的优化器可以通过消除不必要的拷贝、或是将函数内联，而使得这些逻辑更加高效。</p>\n<p>如果你使用这种方式来建模 <code class=\"language-text\">try/catch/finally</code> 代码块（大概需要使用 <code class=\"language-text\">goto</code>），你就会知道为什么编译器难以优化那些使用了不受检查的异常的代码。大量的隐式控制流在作祟！</p>\n<p>不管怎样，这个例子非常生动地展示了返回错误码方式的缺点。这些错误处理的代码其实很少有机会被执行（当然，我们需要假设故障发生的频率没那么高），但它们仍然在热路径（Hot Path）上，会影响程序在主要场景下的性能。这违背了我们最重要的准则之一。</p>\n<p>我在<a href=\"https://joeduffyblog.com/2015/12/19/safe-native-code/\">上一篇博客</a>中描述了我们对两种模式的实验。简单来说，使用异常来实现的话，我们做到了平均减小 7% 的程序体积、提高 4% 的执行速度。原因在于：</p>\n<ul>\n<li>调用约定没有受到影响。</li>\n<li>调用函数时不需要做分支检查。</li>\n<li>在类型系统中，所有会抛出异常的函数都是已知的，因此能够实现更灵活的代码移动。</li>\n<li>在类型系统中，所有会抛出异常的函数都是已知的，因此能够让我们实现一些更新颖的错误处理优化，例如当 <code class=\"language-text\">try</code> 块中没有异常会抛出时，可以把 <code class=\"language-text\">try/finally</code> 块展平。</li>\n</ul>\n<p>还有其他原因使得异常更加高效。我已经提到了，我们不会像大多数异常系统一样遍历调用栈、收集元数据。我们把诊断功能留给了我们的诊断子系统。另一个常见的模式在这同样有所帮助：将异常缓存为不可变的对象，使得 <code class=\"language-text\">throw</code> 时不会发生内存申请：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">const</span> <span class=\"token class-name\">Exception</span> retryLayout <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">throw</span> retryLayout<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>对于会频繁抛出和捕获异常的系统来说——例如我们的语法分析器、FRP UI 框架（译注：Functional Reactive Programming，函数式反应式编程范式）等等——这种方法对于提高性能非常重要。这也很好地说明了，我们最好不要把“异常很慢”当作真理来对待。</p>\n<h2 id=\"模式pattern\" style=\"position:relative;\"><a href=\"#%E6%A8%A1%E5%BC%8Fpattern\" aria-label=\"模式pattern permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>模式（Pattern）</h2>\n<p>在我们的语言和类库中，我们添加了很多有用的模式。</p>\n<h3 id=\"并发\" style=\"position:relative;\"><a href=\"#%E5%B9%B6%E5%8F%91\" aria-label=\"并发 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>并发</h3>\n<p>回到 2007 年，我写了一篇<a href=\"https://joeduffyblog.com/2009/06/23/concurrency-and-exceptions/\">有关并发和异常的博客文章</a>。这篇文章主要是从并行、共享内存计算的角度来写的，但那些难点是所有的并发调度模式所共有的。我们遇到的基本问题在于：异常是基于单一连续的栈、以及单一失败模式来实现的。在一个并发系统中，你可能有多个栈、多种失败模式，很多情况都有可能“同时”发生。</p>\n<p>Midori 所做的一个简单的改进是，它会保证所有与 <code class=\"language-text\">Exception</code> 相关的基础设施都能够处理多个内层错误。至少当有多个错误信息同时存在时，程序员不用考虑究竟要留下哪一个。更重要的是，调度和栈爬取设施从根本上掌握着这些“仙人掌风格”的栈的信息，也知道如何作出处理。这多亏了我们的异步模型。</p>\n<p>一开始，我们不支持异常跨越出异步执行的边界。然而最后我们还是扩展了异常系统，使得异常能够跨越异步边界。这就为异步角色编程模型（Asynchronous Actors Programming Model）引入了一个强大的、有类型支持的编程模型，就像是一种自然的扩展。我们从 CLU 的继任者 <a href=\"https://en.wikipedia.org/wiki/Argus_%28programming_language%29\">Argus</a> 那里学习了一个。</p>\n<p>我们的诊断设施在其“栈视图”里提供了一种全面的、跨进程因果关系的调试体验。在高度并发的系统中，栈不仅仅是“仙人掌”式的，它们还经常出现在进程之间的消息传递边界上。支持这种形式的调试，为开发人员节省了大量的时间。</p>\n<h3 id=\"中止\" style=\"position:relative;\"><a href=\"#%E4%B8%AD%E6%AD%A2\" aria-label=\"中止 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>中止</h3>\n<p>有时，某个子系统需要“快速脱离苦海”。当遇到 Bug 时，放弃是一种选择。在一个进程中没什么东西能阻止放弃的执行。不过，在确认条件允许的情况下，我们能不能把调用栈恢复到某个时间点、进行恢复、然后在同一个进程中继续执行？</p>\n<p>异常比较接近我们的需求。但不幸的是，在调用栈上的代码能够捕获异常，并将其屏蔽掉。我们想要一个不能被屏蔽的东西。</p>\n<p>这个“东西”就是中止（Abort）。我们发明中止，主要是因为我们的 UI 框架使用了函数式反应式编程（FRP），这种编程范式在其他一些地方也有应用。当 FRP 重计算发生时，某些事件、或是某些新的发现会令当前的计算失效——例如，当某些计算的调用栈中同时包含了用户代码和系统代码的时候。如果这种情况发生了， FRP 引擎就需要返回栈顶，从而能够安全地开启新一轮计算。由于我们的用户代码是纯函数式的，在其间中止执行非常简单，也不会发生错误的副作用。同时，由于使用了类型化的异常，我们的引擎代码能够被彻底审查并加固，以此来保证满足所有的不变量的条件。</p>\n<p>中止的设计借鉴于 <a href=\"https://joeduffyblog.com/2015/11/10/objects-as-secure-capabilities/\">capability playbook</a> 。首先，我们引入了一个基类，叫做 <code class=\"language-text\">AbortException</code>。它可以直接使用，也可以派生出子类。有一点比较特别：没人能够捕获这个异常然后忽略它。如果有任何 <code class=\"language-text\">catch</code> 试图捕获它，它就会自动地 <code class=\"language-text\">catch</code> 块的结尾再次抛出。我们把这种异常叫做 <em>不可屏蔽的（undeniable）</em>。</p>\n<p>但总是要有人能够捕获中止的。整个思路就是退出某个上下文，而不是放弃整个进程。我们将会看到如何获得捕获中止的能力。下面是 <code class=\"language-text\">AbortException</code> 的样子：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> immutable <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbortException</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">Exception</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">AbortException</span><span class=\"token punctuation\">(</span>immutable <span class=\"token class-name\"><span class=\"token keyword\">object</span></span> token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Reset</span><span class=\"token punctuation\">(</span>immutable <span class=\"token class-name\"><span class=\"token keyword\">object</span></span> token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 省略了其他不重要的成员...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>需要注意的是，构造函数接收了一个不可变的 <code class=\"language-text\">token</code>；如果不想再继续向上层抛出，就需要调用<code class=\"language-text\">Reset</code> 方法，同时必须传入一个相同的 <code class=\"language-text\">token</code>。如果 <code class=\"language-text\">token</code> 不匹配的话，就触发放弃。这里的思路是，抛出和想要捕获中止的模块通常是同一个，或者二者之间至少有协同关系，能够彼此安全地共享 <code class=\"language-text\">token</code>。这是一个典型的对象具有不可伪造特性的例子。</p>\n<p>当然，调用栈上的任何一段代码都可以触发放弃，但只要简单地对 <code class=\"language-text\">null</code> 解引用就可以实现了。这种技术禁止在中止上下文中执行，因为上下文可能还没有作出足够的准备。</p>\n<p>一些其他的框架也有类似的模式。.NET Framework 中有 <code class=\"language-text\">ThreadAbortException</code>，这同样是一种不可屏蔽的异常，只有调用 <code class=\"language-text\">Thread.ResetAbort</code> 才可以将其捕获。不过，由于这种异常不是基于能力的（译注：参见 <a href=\"https://en.wikipedia.org/wiki/Capability-based_security\">Compatibility-based Security</a>），因此它需要安全注释（Security Annotations）和宿主 API 的同时努力，才能够防止中止被意外地屏蔽。老话重提，这种异常也是不受检查的。</p>\n<p>由于异常是不可变的，上文提到的 <code class=\"language-text\">token</code> 也是不可变的，一种常见的做法是把这些东西利用单例缓存到静态变量中。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token class-name\"><span class=\"token keyword\">object</span></span> abortToken <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\"><span class=\"token keyword\">object</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token class-name\">AbortException</span> abortException <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">AbortException</span><span class=\"token punctuation\">(</span>abortToken<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Abort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token return-type class-name\">throws</span> AbortException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> abortException<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">TopOfTheStack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 调用一些其他函数</span>\n            <span class=\"token comment\">// 调用栈的某处可能会中止，我们将其捕获并重置：</span>\n            <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">catch</span><span class=\"token operator\">&lt;</span>AbortException<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>IsFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                result<span class=\"token punctuation\">.</span>Exception<span class=\"token punctuation\">.</span><span class=\"token function\">Reset</span><span class=\"token punctuation\">(</span>abortToken<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这种模式使得中止非常的高效。平均来说一次 FRP 计算会中止多次。要记得， FRP 是系统中所有 UI 的基石，因此不能因为使用了异常就影响性能——申请一个异常对象可能都会不幸地触发 GC。</p>\n<h3 id=\"可选的try-api\" style=\"position:relative;\"><a href=\"#%E5%8F%AF%E9%80%89%E7%9A%84try-api\" aria-label=\"可选的try api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>可选的“Try” API</h3>\n<p>上文提到过，很多操作失败时都会触发放弃，例如申请内存、算术计算溢出或是零除，等等。在某些情况下中，有一些失败更适合动态的错误传播和恢复，而不是直接触发放弃。当然，放弃在大多数情况下都是更好的选择。</p>\n<p>这也变成了一种模式。不是很常用，但我们也提供。我们提供了一系列的算数 API，它们使用了数据流风格的传播（Propagation）来处理溢出、NaN 或是其他的情况。</p>\n<p>我在前面已经提到了这项功能的具体例子——我们使用 <code class=\"language-text\">try new</code> 来申请内存，这时内存不足将产生一个可恢复错误，而不是触发放弃。这极其少见，但有时还是很有用的，例如当你想申请一大块缓存来做一些多媒体操作的时候。</p>\n<h3 id=\"看守人\" style=\"position:relative;\"><a href=\"#%E7%9C%8B%E5%AE%88%E4%BA%BA\" aria-label=\"看守人 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>看守人</h3>\n<p>这里介绍的最后一种模式，叫做 <em>看守人模式（the keeper pattern）</em>。</p>\n<p>在很多方面，可恢复异常都是“由内而外”地进行处理。一堆代码执行了，向下传递了一些参数，知道某段代码发现自己的状态有点问题。然后，在异常模型中，控制流重新沿着调用栈向上传播，进行栈展开，直到某段代码能够处理这个错误。如果此时决定需要重试的话，就再次执行一系列的操作。</p>\n<p>一种可选的替代模式是使用看守人。看守人是一个对象，它知道如何“就地”从错误当中恢复，因此调用栈就不需要展开了。相反，之前需要抛出异常的代码，现在可以咨询看守人，而它就可以对如何继续执行做出指示。看守人的好处之一是，如果它作为一项配置能力时（configured capability），周围的代码甚至不需要知道它们的存在。这就与异常不同，在我们的系统中，异常是类型系统的一部分。看守人的另一个好处是，它们非常简单，代价也不高。</p>\n<p>Midori 中的看守人可以用来做一些提示的操作，不过更常见的是用来跨越异步的边界。</p>\n<p>看守人典型的使用场景是对文件系统操作进行保护。访问文件系统中的文件和目录通常会由于这些原因失败：</p>\n<ul>\n<li>不合法的路径</li>\n<li>文件没找到</li>\n<li>目录没找到</li>\n<li>文件正在使用</li>\n<li>权限不足</li>\n<li>设备已满</li>\n<li>设备写保护</li>\n</ul>\n<p>一种方案是，对每一个文件系统 API 都标注为 <code class=\"language-text\">throws</code>。或者像 Java 一样，创建一套 <code class=\"language-text\">IOException</code> 的体系，把它们作为子类。而另一种方案就是使用看守人。这保证了应用程序整体上不需要知道、或是不需要关心 IO 错误，能够让错误恢复逻辑集中在一起。这个看守人的接口可能会是这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">IFileSystemKeeper</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">async</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">string</span></span> <span class=\"token function\">InvalidPathSpecification</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span></span> path<span class=\"token punctuation\">)</span> throws<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">async</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">string</span></span> <span class=\"token function\">FileNotFound</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span></span> path<span class=\"token punctuation\">)</span> throws<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">async</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">string</span></span> <span class=\"token function\">DirectoryNotFound</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span></span> path<span class=\"token punctuation\">)</span> throws<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">async</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">string</span></span> <span class=\"token function\">FileInUse</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span></span> path<span class=\"token punctuation\">)</span> throws<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">async</span> <span class=\"token return-type class-name\">Credentials</span> InsufficientPrivileges<span class=\"token class-name\"><span class=\"token punctuation\">(</span>Credentials creds<span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span> path<span class=\"token punctuation\">)</span></span> throws<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">async</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">string</span></span> <span class=\"token function\">MediaFull</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span></span> path<span class=\"token punctuation\">)</span> throws<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">async</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">string</span></span> <span class=\"token function\">MediaWriteProtected</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span></span> path<span class=\"token punctuation\">)</span> throws<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的想法是，对于每种情况，当错误发生时，相关的输入都会提供给看守人。看守人随后会执行一些操作——也许是异步的——来进行恢复。很多时候，看守人可以选择返回一个新的参数来执行这项操作。例如，<code class=\"language-text\">InsufficientPrivileges</code> 可以返回一个替代的 <code class=\"language-text\">Credentials</code> 来使用。（程序可以向用户弹出一个提示框，让用户切换到有写权限的账户。）对于上面列举的每一种情况，如果看守人不想处理的话，也可以抛出异常，不过这个功能不是看守人模式必须提供的。</p>\n<p>最后，我应该说明的是，Windows的结构化异常处理（Structured Exception Handling，SEH）支持“可继续的”异常，它们从概念上讲是一样的。SEH 允许让某段代码来决定如何重新执行失败的计算。不过遗憾的是，SEH 使用了调用栈上的环境处理函数，而不是语言中的一等公民对象，这让它看起来不那么美观，而且更容易出错。</p>\n<h2 id=\"后续的方向effect-typing\" style=\"position:relative;\"><a href=\"#%E5%90%8E%E7%BB%AD%E7%9A%84%E6%96%B9%E5%90%91effect-typing\" aria-label=\"后续的方向effect typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>后续的方向：Effect Typing</h2>\n<p>很多人都问过我们，在类型系统中加上 <code class=\"language-text\">async</code> 和 <code class=\"language-text\">throws</code> 会不会让库代码变得更加臃肿。答案是“不会”。不过在高度多态的库代码中，这确实是件令人头痛的事。</p>\n<p>最让人不安的是那些组合子，例如 map，filter，sort，等等。在这些情况下，你通常会希望那些带有 <code class=\"language-text\">async</code> 和 <code class=\"language-text\">throws</code> 的函数能够透明地“流过”。</p>\n<p>我们用来解决这个问题的方案是，允许你使用效果（Effect）来参数化类型。例如，这是一个通用的映射函数 <code class=\"language-text\">Map</code>，它把它的 <code class=\"language-text\">func</code> 参数上的 <code class=\"language-text\">async</code> 或是 <code class=\"language-text\">throws</code> 效果进行传播：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token return-type class-name\">U<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> Map<span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span> U<span class=\"token punctuation\">,</span> effect E<span class=\"token operator\">></span><span class=\"token return-type class-name\"><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> ts<span class=\"token punctuation\">,</span> Func<span class=\"token punctuation\">&lt;</span>T<span class=\"token punctuation\">,</span> U<span class=\"token punctuation\">,</span> E<span class=\"token punctuation\">></span> func<span class=\"token punctuation\">)</span></span> E <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">U<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> us <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">U</span><span class=\"token punctuation\">[</span>ts<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> ts<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        us<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span>E<span class=\"token punctuation\">)</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>ts<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> us<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>需要注意的是，我们使用了一个常规的泛型类型E，只是在它前面多了一个关键字 <code class=\"language-text\">effect</code>。而后我们就可以用 <code class=\"language-text\">E</code> 来符号化地用在 <code class=\"language-text\">Map</code> 的效果列表里，同时还在“传播”时使用了它——通过 <code class=\"language-text\">effect(E)</code> 来传播调用 <code class=\"language-text\">func</code> 时产生的效果。我们可以简单地把 <code class=\"language-text\">E</code> 替换为 <code class=\"language-text\">throws</code>、<code class=\"language-text\">effect(E)</code> 替换为 <code class=\"language-text\">try</code>，来看一看背后的逻辑转换。</p>\n<p>对 <code class=\"language-text\">Map</code> 的合法调用如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> xs <span class=\"token operator\">=</span> <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\"><span class=\"token keyword\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> ys <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token generic-method\"><span class=\"token function\">Map</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">,</span> throws<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span>xs<span class=\"token punctuation\">,</span> x <span class=\"token operator\">=></span> <span class=\"token range operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>由于 <code class=\"language-text\">throws</code> 会“流过”内部操作，我们因此可以传入一个会抛出异常的回调函数。</p>\n<p>总而言之，我们进一步讨论了这个想法，并允许程序员声明任意多的效果。我<a href=\"https://joeduffyblog.com/2010/04/25/from-simple-annotations-for-analysis-to-effect-typing/\">之前就设想过这样的类型系统</a>。不过我们还是有些顾虑，无论这种高阶编程多么强大，它们也许都只是小聪明，而且还难以理解。上面这个简单的模型也许看起来不错，如果在多给我几个月的时间，我们也许能够把它实现出来。</p>"},"childMdx":null}},{"node":{"id":"c278fd2e-8d24-5851-82d3-86b8732cdfa1","relativePath":"the-error-model/6-retrospective-and-conclusions.md","childMarkdownRemark":{"fields":{"slug":"/the-error-model/6-retrospective-and-conclusions/"},"frontmatter":{"title":"六、回顾和总结"},"html":"<p>这趟旅程终于快要结束了。就像我一开始提到的一样，这趟旅程也许没什么惊喜，平淡无奇。但我希望所有的这些背景历程能够帮助你在错误模型方面取得更多的进展。</p>\n<p>总结一下，我们最终的模型：</p>\n<ul>\n<li>具备一个良好的架构，能够细粒度地提供隔离，并在失败时提供恢复能力。</li>\n<li>区分 Bug 和可恢复错误。</li>\n<li>对于所有的 Bug，使用合约、断言，以及放弃来处理。</li>\n<li>对于可恢复错误，使用精简的受检查异常模型来处理，它还有强大的类型系统和语言语法的支持。</li>\n<li>汲取了返回错误码的部分优点（比如局部检查）来提高可靠性。</li>\n</ul>\n<p>虽然这是一个持续了多年的旅程，但一直到我们的项目被砍掉时，我们还是在不断地做出改进。有些改进没有写入上面的列表中，因为我们还没有足够的经验来表明它们一定能成功。多希望我们能够走的更远、把那些功能都真正发布出来啊！特别是，我真的很想把下面这一点放入我们的最终总结当中：</p>\n<ul>\n<li>默认使用非空类型，从而消除大量的不可空标注。</li>\n</ul>\n<p>放弃，以及我们大量使用放弃的程度，在我看来是我们在错误模型方面最成功的赌注。我们经常能够及早发现 Bug，在它们还很容易调试的时候修掉。基于放弃的错误和可恢复错误大约比例为 10:1，这使得受检查的异常很少见，开发人员也能够接受使用受检查的异常。</p>\n<p>尽管我们没能成功的发布这套系统，还是有一些经验可以带到其他的项目中去的。</p>\n<p>例如，在把 Internet Explorer 重写为 Microsoft Edge 时，我们在一些地方采用了放弃。最关键的一处就是内存不足，这是由一个 Midori 工程师实现的。就像我上文中提到的那样，老的代码在内存不足时还会尝试继续一瘸一拐地走下去，而此时它通常都是在做错误的事情。我的理解是，放弃能够发现相当多的潜在 Bug，我们在移植现有代码到 Midori 上时经常会遇到。另一个很棒的地方在于，放弃更像是一种架构层面的准则，可以在不同语言的现有代码中使用。</p>\n<p>细粒度隔离的体系基础非常关键，然而许多系统对这种架构都只有非正式的概念。在浏览器中，内存不足时采用放弃工作的很好，原因之一就是大多数浏览器都已经把单独的标签页放在独立的进程中了。浏览器在很多方面都在模拟一个操作系统，这也是其中之一。</p>\n<p>最近，我们还在探索把这些准则——<a href=\"https://www.youtube.com/watch%3Fv%3DHjz1eBx91g8\">包括合约</a>——带入C++。同样，对于 C#，我们也有某些功能带入其中的<a href=\"https://github.com/dotnet/roslyn/issues/119\">具体提议</a>。我们还在非常积极地改进一份<a href=\"https://github.com/dotnet/roslyn/issues/5032\">把非空检查带入 C# 的提议</a>。我希望这些提议一切顺利，但是需要承认的是，这些语言并不是从一开始就遵循同样的错误处理准则，因此这些特性未必能够做到完美无缺。同样需要注意的是，整个隔离和并发模型对于放弃来说同样至关重要。</p>\n<p>我希望，我持续地分享这些知识，能够让更多人了解、采用这些想法。</p>\n<p>当然，正如我提到的那样，Go、Rust 和 Swift 为我们提供了非常棒的、适合系统开发的错误模型。我也许还是有一点小挑剔，但事实是它们要比 Midori 刚启动时工业界的所有模型都要好。这真是一个系统程序员的好时代！</p>\n<p>下次我会谈一谈我们使用的语言。尤其是，我们会看到，Midori 是如何使用包括架构、语言支持和库在内的神奇药水来驯服垃圾收集器的。期待与你下次再见！</p>"},"childMdx":null}},{"node":{"id":"126c57c4-f7de-5e95-ac10-778090b6961b","relativePath":"the-error-model/short-intro.md","childMarkdownRemark":{"fields":{"slug":"/the-error-model/short-intro/"},"frontmatter":{"title":""},"html":"<p>原作者 <a href=\"http://joeduffyblog.com/\">Joe Duffy</a> 曾在微软参与开发一款操作系统 Midori，这是一款研究型项目。他的团队在编写这款操作系统的过程当中积累了相当多的经验，作者后来撰写了多篇文章回忆了这些经历。这一系列来自于<a href=\"http://joeduffyblog.com/2016/02/07/the-error-model/\">其中的一篇文章</a>，主要讨论了编程语言中关于错误模型的思考和实践。</p>"},"childMdx":null}}]}}}